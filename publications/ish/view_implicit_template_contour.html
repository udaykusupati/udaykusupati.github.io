<!DOCTYPE html>
<html lang="en">
<link rel="shortcut icon" href="#">

<link href="https://fonts.googleapis.com/css?family=Overlock" rel="stylesheet">
<style> * { font-family: Overlock; } </style> </head>

  <body>
    <center>
  
    <h1>Implicit Template Visualization</h1>

    Select Template:
    <select id="template" name="template">
      <option value="vase_generator_fixbw">vase</option>
      <option value="mug">mug</option>
      <option value="couch">couch</option>
      <option value="table">table</option>
      <option value="airplane_simple">airplane</option>
      <option value="car">car</option>
      <option value="box_simple">box simple</option>
      <option value="box_double">box double</option>
      <option value="box_three">box three</option>
      <option value="box_cylinder_twist">box cylinder twist</option>
    </select>

    <br><br>

    <table>
      <tr>
        <td>
          <canvas id='scene' style="border: 1px solid black;"></canvas>
        </td>
        <td>
          <div id="params_list"></div>
        </td>
      </tr>
    </table>

    </center>

    <script type="module">

        import * as THREE from 'https://cdn.skypack.dev/three@0.129.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/controls/OrbitControls.js';
        import { OBJLoader } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/loaders/OBJLoader.js';

        var raymarching_glsl_code = `

/// Code from : https://github.com/nicoptere/raymarching-for-THREE/blob/master/glsl/interactive.glsl


uniform vec2 resolution;
uniform float fov;
uniform float raymarchMaximumDistance;
uniform float raymarchPrecision;
uniform vec3 camera;
uniform vec3 target;

uniform vec3 color0;
uniform vec3 color1;
uniform vec3 color2;

uniform vec3 light0;
uniform vec3 light1;

float colormap_red(float x) {
	if (x < 0.09771832105856419) {
		return 7.60263247863246E+02 * x + 1.02931623931624E+02;
	} else if (x < 0.3017162107441106) {
		return (-2.54380938558548E+02 * x + 4.29911571188803E+02) * x + 1.37642085716717E+02;
	} else if (x < 0.4014205790737471) {
		return 8.67103448276151E+01 * x + 2.18034482758611E+02;
	} else if (x < 0.5019932233215039) {
		return -6.15461538461498E+01 * x + 2.77547692307680E+02;
	} else if (x < 0.5969483882550937) {
		return -3.77588522588624E+02 * x + 4.36198819698878E+02;
	} else if (x < 0.8046060096654594) {
		return (-6.51345897546620E+02 * x + 2.09780968434337E+02) * x + 3.17674951640855E+02;
	} else {
		return -3.08431855203590E+02 * x + 3.12956742081421E+02;
	}
}

float colormap_green(float x) {
	if (x < 0.09881640500975222) {
		return 2.41408547008547E+02 * x + 3.50427350427364E-01;
	} else if (x < 0.5000816285610199) {
		return ((((1.98531871433258E+04 * x - 2.64108262469187E+04) * x + 1.10991785969817E+04) * x - 1.92958444776211E+03) * x + 8.39569642882186E+02) * x - 4.82944517518776E+01;
	} else if (x < 0.8922355473041534) {
		return (((6.16712686949223E+03 * x - 1.59084026055125E+04) * x + 1.45172137257997E+04) * x - 5.80944127411621E+03) * x + 1.12477959061948E+03;
	} else {
		return -5.28313797313699E+02 * x + 5.78459299959206E+02;
	}
}

float colormap_blue(float x) {
	if (x < 0.1033699568661857) {
		return 1.30256410256410E+02 * x + 3.08518518518519E+01;
	} else if (x < 0.2037526071071625) {
		return 3.38458128078815E+02 * x + 9.33004926108412E+00;
	} else if (x < 0.2973267734050751) {
		return (-1.06345054944861E+02 * x + 5.93327252747168E+02) * x - 3.81852747252658E+01;
	} else if (x < 0.4029109179973602) {
		return 6.68959706959723E+02 * x - 7.00740740740798E+01;
	} else if (x < 0.5006715489526758) {
		return 4.87348695652202E+02 * x + 3.09898550724286E+00;
	} else if (x < 0.6004396902588283) {
		return -6.85799999999829E+01 * x + 2.81436666666663E+02;
	} else if (x < 0.702576607465744) {
		return -1.81331701891043E+02 * x + 3.49137263626287E+02;
	} else if (x < 0.9010407030582428) {
		return (2.06124143164576E+02 * x - 5.78166906665595E+02) * x + 5.26198653917172E+02;
	} else {
		return -7.36990769230737E+02 * x + 8.36652307692262E+02;
	}
}

vec4 colormap(float x) {
	float r = clamp(colormap_red(x) / 255.0, 0.0, 1.0);
	float g = clamp(colormap_green(x) / 255.0, 0.0, 1.0);
	float b = clamp(colormap_blue(x) / 255.0, 0.0, 1.0);
	return vec4(r, g, b, 1.0);
}


//uses most of the StackGL methods
//https://github.com/stackgl

//https://github.com/hughsk/glsl-square-frame

vec2 squareFrame(vec2 screenSize) {
  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;
  position.x *= screenSize.x / screenSize.y;
  return position;
}
vec2 squareFrame(vec2 screenSize, vec2 coord) {
  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;
  position.x *= screenSize.x / screenSize.y;
  return position;
}

//https://github.com/stackgl/glsl-look-at/blob/gh-pages/index.glsl

mat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {
  vec3 rr = vec3(sin(roll), cos(roll), 0.0);
  vec3 ww = normalize(target - origin);
  vec3 uu = normalize(cross(ww, rr));
  vec3 vv = normalize(cross(uu, ww));
  return mat3(uu, vv, ww);
}

//https://github.com/stackgl/glsl-camera-ray

vec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {
  return normalize(camMat * vec3(screenPos, lensLength));
}
vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {
  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);
  return getRay(camMat, screenPos, lensLength);
}


/////////////////////////////////////////////////////////////////////////


const int raymarchSteps = 50;

vec2 field( vec3 position )
{
    return vec2( eval_distance( position ) , 1. );   // function defined in template glsl
}

/////////////////////////////////////////////////////////////////////////

// the methods below this need the field function

/////////////////////////////////////////////////////////////////////////


//the actual raymarching from:
//https://github.com/stackgl/glsl-raytrace/blob/master/index.glsl

vec2 raymarching( vec3 rayOrigin, vec3 rayDir, float maxd, float precis ) {

    float latest = precis * 2.0;
    float dist   = 0.0;
    float type   = -1.0;
    for (int i = 0; i < raymarchSteps; i++) {

        if (latest < precis || dist > maxd) break;

        vec2 result = field( rayOrigin + rayDir * dist );
        latest = result.x;
        dist  += latest;

        type = result.y;
    }

    vec2 res    = vec2(-1.0, -1.0 );
    if (dist < maxd) { res = vec2( dist, type ); }
    return res;

}

//https://github.com/stackgl/glsl-sdf-normal

vec3 calcNormal(vec3 pos, float eps) {
  const vec3 v1 = vec3( 1.0,-1.0,-1.0);
  const vec3 v2 = vec3(-1.0,-1.0, 1.0);
  const vec3 v3 = vec3(-1.0, 1.0,-1.0);
  const vec3 v4 = vec3( 1.0, 1.0, 1.0);

  return normalize( v1 * field( pos + v1*eps ).x +
                    v2 * field( pos + v2*eps ).x +
                    v3 * field( pos + v3*eps ).x +
                    v4 * field( pos + v4*eps ).x );
}

vec3 calcNormal(vec3 pos) {
  return calcNormal(pos, 0.002);
}


void main() {

    vec2  screenPos    = squareFrame( resolution );

    vec3  rayDirection = getRay( camera, target, screenPos, fov );

    vec2 collision = raymarching( camera, rayDirection, raymarchMaximumDistance, raymarchPrecision );

    gl_FragColor = vec4( mix( color0, color1, sin( screenPos.y + 1.5 ) ) * 2., 0. );
    
    vec3 pos_int = camera + rayDirection * collision.x;
    if ( collision.x > -0.5 && collision.x < -camera.z / rayDirection.z && pos_int.z > 0.0)
    // if ( true)
    {

        //"world" position
        vec3 pos = camera + rayDirection * collision.x;

        //diffuse color
        vec3 col = vec3( 0.5, 0.5, 0.5 );

        //normal vector
        vec3 nor = calcNormal( pos );

        vec3 lig0 = normalize( light0 );
        vec3 lightColor0 =  max( 0.0, dot( lig0, nor) ) * color0;

        vec3 lightColor1 = max( 0.0, dot( normalize( light1 ), nor) ) * color1;
        if (collision.x > -0.5) 
        {
            lightColor1 = max( 0.0, dot( normalize( light1 ), nor) ) * color2;

            float depth = 0.6;

            gl_FragColor = vec4( ( col + lightColor0 + lightColor1 ) * depth, 0.5 );
        }
        

    }
    else {
      // choose collision with z = 0 frame
      vec3  rayDirection = getRay( camera, target, screenPos, fov );
      vec2 collision = vec2(-camera.z / rayDirection.z, 1.0);
      vec3 pos = camera + rayDirection * collision.x;
      vec3 nor = vec3(0.0, 0.0, 1.0);

      float dist = field(pos).x;
      float maxDist = 1.0;
      float minDist = -1.0;
      float absdist = abs(dist);
      if (dist < 0.0) {
        dist = -1.0 + 2.0/(1.0 + exp(-dist*10.0));
      }
      float distNorm = (dist - minDist) / (maxDist - minDist);
      float diff = absdist*20.0 - floor(absdist*20.0);
      if (diff < 0.02) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
      } else {
        gl_FragColor = colormap(distNorm);
      }
    }

}`;

        var templates_glsl_dict = {"couch": "//// PREAMBLE\n\nfloat opp(float vv) { return -vv; }\n\nfloat vmin(vec2 vv) { return min(vv.x, vv.y); }\nfloat vmin(vec3 vv) { return min(min(vv.x, vv.y), vv.z); }\nfloat vmin(vec4 vv) { return min(min(vv.x, vv.y), min(vv.z, vv.w)); }\n\nfloat vmax(vec2 vv) { return max(vv.x, vv.y); }\nfloat vmax(vec3 vv) { return max(max(vv.x, vv.y), vv.z); }\nfloat vmax(vec4 vv) { return max(max(vv.x, vv.y), max(vv.z, vv.w)); }\n\n// According to the Kronos documentation, the fract of the input is computing\n// in this way 'x-floor(x)' which result to wrong results with negative values.\nfloat fractOfPositiveAndNegativeValue(float vv) {\n  return vv < 0.0 ? vv - ceil(vv) : vv - floor(vv);\n}\nvec2 fractOfPositiveAndNegativeValue(vec2 vv) {\n  return vec2(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y));\n}\nvec3 fractOfPositiveAndNegativeValue(vec3 vv) {\n  return vec3(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z));\n}\nvec4 fractOfPositiveAndNegativeValue(vec4 vv) {\n  return vec4(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z),\n    fractOfPositiveAndNegativeValue(vv.w));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n  float n = dot(i, step);\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec2 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec3 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n// https://www.pcg-random.org/\nfloat noisePcg(float q){\n  uint v = uint(round(q));\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float(float((word >> 22u) ^ word) * (1.0/float(0xffffffffu))) ;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh  \nvec2 noisePcg(vec2 q){\n  uvec2 v = uvec2(q);\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  return vec2(vec2(v)* (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec3 noisePcg(vec3 q){\n  uvec3 v = uvec3(q);\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  \n  return vec3(vec3(v) * (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec4 noisePcg(vec4 q){\n  uvec4 v = uvec4(q);\n  v = v * 1664525u + 1013904223u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  v ^= v >> 16u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  return vec4(vec4(v) * (1.0/float(0xffffffffu)));\n}\n\n\n//// CUSTOM TYPES\n\nstruct t_zero {\n\tfloat v_value;\n};\n\nstruct t_stdconsts {\n\tfloat v_zero;\n\tvec3 v_origin;\n\tfloat v_one;\n\tfloat v_dotfive;\n\tfloat v_two;\n\tfloat v_ten;\n};\n\nstruct t_translation {\n\tfloat v_trans_X;\n\tfloat v_trans_Y;\n\tfloat v_trans_Z;\n\tfloat v_rot_Y;\n};\n\nstruct t_cyl_rot {\n\tfloat v_angle_X;\n};\n\nstruct t_params {\n\tfloat v_width;\n\tfloat v_height;\n\tfloat v_depth;\n\tfloat v_armrest_width;\n\tfloat v_cushion_height;\n\tfloat v_foot_height;\n\tfloat v_back_width;\n\tfloat v_armrest_height;\n\tfloat v_back_angle;\n\tfloat v_pillow_width;\n\tfloat v_pillow_depth;\n\tfloat v_pillow_shell;\n\tfloat v_pillow_spacing;\n\tfloat v_pillow_angle;\n\tfloat v_pillow_angle_back;\n\tfloat v_armrest_shell;\n\tfloat v_back_shell;\n\tfloat v_cushion_shell;\n};\n\nstruct t_position {\n\tvec3 v_pos;\n};\nstruct t_outlet {\n\tfloat v_dist;\n};\n\nstruct t_cube_inlet {\n\tvec3 v_pos;\n\tvec3 v_size;\n};\nstruct t_cube_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_rotate_inlet {\n\tvec3 v_pos;\n\tfloat v_angle_x;\n\tfloat v_angle_y;\n\tfloat v_angle_z;\n};\nstruct t_modpre_rotate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_ellipsoid_inlet {\n\tvec3 v_pos;\n\tvec3 v_size;\n};\nstruct t_ellipsoid_outlet {\n\tfloat v_dist;\n};\n\nstruct t_union_inlet {\n\tfloat v_a;\n\tfloat v_b;\n};\nstruct t_union_outlet {\n\tfloat v_o0;\n};\n\nstruct t_modpre_translate_inlet {\n\tvec3 v_pos;\n\tvec3 v_offset;\n};\nstruct t_modpre_translate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_cylinder_inlet {\n\tvec3 v_pos;\n\tfloat v_height;\n\tfloat v_radius;\n};\nstruct t_cylinder_outlet {\n\tfloat v_dist;\n};\n\n//// PROTOTYPES\n\n// float operator-(float a_a, float a_b); // FUNCID(5) builtin arithmetic\n// float operator*(float a_a, float a_b); // FUNCID(40) builtin arithmetic\n// vec3 operator-(vec3 a_a, vec3 a_b); // FUNCID(6) builtin arithmetic\n// float operator/(float a_a, float a_b); // FUNCID(70) builtin arithmetic\n// float operator+(float a_a, float a_b); // FUNCID(49) builtin arithmetic\n// float abs(float a_i); // FUNCID(52) builtin operator\n// vec2 max(vec2 a_a, vec2 a_b); // FUNCID(36) builtin operator\n// vec2 operator-(vec2 a_a, vec2 a_b); // FUNCID(21) builtin arithmetic\n// float sin(float a_i); // FUNCID(85) builtin operator\n// float cos(float a_i); // FUNCID(60) builtin operator\n// vec2 abs(vec2 a_i); // FUNCID(58) builtin operator\n// float opp(float a_i); // FUNCID(28) builtin operator\n// float min(float a_a, float a_b); // FUNCID(48) builtin operator\n// vec3 abs(vec3 a_i); // FUNCID(26) builtin operator\n// float vmax(vec3 a_i); // FUNCID(95) builtin operator\n// vec3 max(vec3 a_a, vec3 a_b); // FUNCID(30) builtin operator\n// float length(vec3 a_i); // FUNCID(9) builtin operator\n// vec3 operator*(mat3 a_a, vec3 a_b); // FUNCID(72) builtin arithmetic\n// vec3 operator/(vec3 a_a, vec3 a_b); // FUNCID(96) builtin arithmetic\n// vec3 operator*(vec3 a_a, vec3 a_b); // FUNCID(38) builtin arithmetic\n// float length(vec2 a_i); // FUNCID(7) builtin operator\n// float vmax(vec2 a_i); // FUNCID(68) builtin operator\nt_outlet compute_main_digraph(vec3 a_pos); // FUNCID(152) terminal\nt_cube_outlet compute_cube(vec3 a_pos, vec3 a_size); // FUNCID(112) terminal\nt_modpre_rotate_outlet compute_modpre_rotate(vec3 a_pos, float a_angle_x, float a_angle_y, float a_angle_z); // FUNCID(192) terminal\nt_ellipsoid_outlet compute_ellipsoid(vec3 a_pos, vec3 a_size); // FUNCID(118) terminal\nt_union_outlet compute_union(float a_a, float a_b); // FUNCID(142) terminal\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset); // FUNCID(204) terminal\nt_cylinder_outlet compute_cylinder(vec3 a_pos, float a_height, float a_radius); // FUNCID(109) terminal\n\n//// INSTANCES\n\nconst t_zero c_zero = t_zero(float(0));\nconst t_stdconsts c_stdconsts = t_stdconsts(float(0), vec3(0, 0, 0), float(1), float(0.5), float(2), float(10));\nuniform t_translation u_translation;\nconst t_cyl_rot c_cyl_rot = t_cyl_rot(float(1.571));\nuniform t_params u_params;\n\n//// IMPLEMENTATIONS\n\n// FUNCID(109) 3i->1o ComposeFuncType::Terminal [cylinder_inlet,cylinder_outlet,compute_cylinder]\n// ...\n// ...\nt_cylinder_outlet compute_cylinder(vec3 a_pos, float a_height, float a_radius) {\n\tvec2 tmp006 = vec2(t_cylinder_inlet(a_pos, a_height, a_radius).v_pos.x, t_cylinder_inlet(a_pos, a_height, a_radius).v_pos.y);\n\tvec3 tmp008 = t_cylinder_inlet(a_pos, a_height, a_radius).v_pos;\n\tfloat tmp010 = length(tmp006);\n\tt_cylinder_inlet tmp015 = t_cylinder_inlet(a_pos, a_height, a_radius);\n\tvec2 tmp009 = vec2(tmp010, tmp008.z);\n\tvec2 tmp012 = abs(tmp009);\n\tvec2 tmp007 = vec2(tmp015.v_radius, tmp015.v_height);\n\tvec2 tmp011 = (tmp012 - tmp007);\n\tvec2 tmp001 = vec2(c_stdconsts.v_zero, c_stdconsts.v_zero);\n\tconst t_stdconsts tmp013 = c_stdconsts;\n\tvec2 tmp002 = max(tmp011, tmp001);\n\tfloat tmp000 = vmax(tmp011);\n\tfloat tmp005 = min(tmp000, tmp013.v_zero);\n\tfloat tmp003 = length(tmp002);\n\tfloat tmp004 = (tmp005 + tmp003);\n\treturn t_cylinder_outlet(tmp004);\n}\n\n// FUNCID(112) 2i->1o ComposeFuncType::Terminal [cube_inlet,cube_outlet,compute_cube]\n// ...\n// ...\nt_cube_outlet compute_cube(vec3 a_pos, vec3 a_size) {\n\tt_cube_inlet tmp007 = t_cube_inlet(a_pos, a_size);\n\tvec3 tmp005 = abs(tmp007.v_pos);\n\tvec3 tmp004 = (tmp005 - tmp007.v_size);\n\tconst t_stdconsts tmp001 = c_stdconsts;\n\tfloat tmp003 = vmax(tmp004);\n\tvec3 tmp002 = max(tmp004, tmp001.v_origin);\n\tfloat tmp009 = min(tmp003, tmp001.v_zero);\n\tfloat tmp000 = length(tmp002);\n\tfloat tmp008 = (tmp009 + tmp000);\n\treturn t_cube_outlet(tmp008);\n}\n\n// FUNCID(118) 2i->1o ComposeFuncType::Terminal [ellipsoid_inlet,ellipsoid_outlet,compute_ellipsoid]\n// ...\n// ...\nt_ellipsoid_outlet compute_ellipsoid(vec3 a_pos, vec3 a_size) {\n\tt_ellipsoid_inlet tmp010 = t_ellipsoid_inlet(a_pos, a_size);\n\tvec3 tmp007 = (tmp010.v_pos / tmp010.v_size);\n\tvec3 tmp005 = (tmp010.v_size * tmp010.v_size);\n\tconst t_stdconsts tmp002 = c_stdconsts;\n\tfloat tmp008 = length(tmp007);\n\tvec3 tmp006 = (tmp010.v_pos / tmp005);\n\tfloat tmp003 = (tmp008 - tmp002.v_one);\n\tfloat tmp004 = length(tmp006);\n\tfloat tmp001 = (tmp008 * tmp003);\n\tfloat tmp000 = (tmp001 / tmp004);\n\treturn t_ellipsoid_outlet(tmp000);\n}\n\n// FUNCID(142) 2i->1o ComposeFuncType::Terminal [union_inlet,union_outlet,compute_union]\n// ...\n// ...\nt_union_outlet compute_union(float a_a, float a_b) {\n\tt_union_inlet tmp002 = t_union_inlet(a_a, a_b);\n\tfloat tmp000 = min(tmp002.v_a, tmp002.v_b);\n\treturn t_union_outlet(tmp000);\n}\n\n// FUNCID(192) 4i->1o ComposeFuncType::Terminal [modpre_rotate_inlet,modpre_rotate_outlet,compute_modpre_rotate]\n// ...\n// ...\nt_modpre_rotate_outlet compute_modpre_rotate(vec3 a_pos, float a_angle_x, float a_angle_y, float a_angle_z) {\n\tfloat tmp019 = (cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp015 = (cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp010 = (sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp006 = (sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp026 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z);\n\tfloat tmp025 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z);\n\tfloat tmp023 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y);\n\tfloat tmp022 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_x);\n\tfloat tmp021 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_x);\n\tfloat tmp024 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y);\n\tfloat tmp018 = (tmp019 * tmp021);\n\tfloat tmp016 = (tmp026 * tmp022);\n\tfloat tmp014 = (tmp015 * tmp022);\n\tfloat tmp012 = (tmp026 * tmp021);\n\tfloat tmp009 = (tmp010 * tmp021);\n\tfloat tmp007 = (tmp025 * tmp022);\n\tfloat tmp005 = (tmp006 * tmp022);\n\tfloat tmp003 = (tmp025 * tmp021);\n\tfloat tmp020 = (tmp025 * tmp024);\n\tfloat tmp017 = (tmp018 - tmp016);\n\tfloat tmp013 = (tmp014 + tmp012);\n\tfloat tmp011 = (tmp026 * tmp024);\n\tfloat tmp008 = (tmp009 + tmp007);\n\tfloat tmp004 = (tmp005 - tmp003);\n\tfloat tmp002 = opp(tmp023);\n\tfloat tmp001 = (tmp024 * tmp021);\n\tfloat tmp000 = (tmp024 * tmp022);\n\tt_modpre_rotate_inlet tmp030 = t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z);\n\tmat3 tmp028 = mat3(tmp020, tmp017, tmp013, tmp011, tmp008, tmp004, tmp002, tmp001, tmp000);\n\tvec3 tmp027 = (tmp028 * tmp030.v_pos);\n\treturn t_modpre_rotate_outlet(tmp027);\n}\n\n// FUNCID(204) 2i->1o ComposeFuncType::Terminal [modpre_translate_inlet,modpre_translate_outlet,compute_modpre_translate]\n// ...\n// ...\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset) {\n\tt_modpre_translate_inlet tmp002 = t_modpre_translate_inlet(a_pos, a_offset);\n\tvec3 tmp000 = (tmp002.v_pos - tmp002.v_offset);\n\treturn t_modpre_translate_outlet(tmp000);\n}\n\n// FUNCID(152) 1i->1o ComposeFuncType::Terminal [position,outlet,compute_main_digraph]\n// ...\n// ...\nt_outlet compute_main_digraph(vec3 a_pos) {\n\tfloat tmp086 = (c_stdconsts.v_ten - c_stdconsts.v_two);\n\tfloat tmp087 = (tmp086 / c_stdconsts.v_ten);\n\tfloat tmp057 = sin(u_params.v_back_angle);\n\tfloat tmp076 = (u_params.v_back_width * c_stdconsts.v_two);\n\tfloat tmp070 = (c_stdconsts.v_two * u_params.v_cushion_height);\n\tfloat tmp055 = cos(u_params.v_back_angle);\n\tfloat tmp025 = opp(u_params.v_depth);\n\tfloat tmp048 = (u_params.v_foot_height * c_stdconsts.v_dotfive);\n\tconst t_zero tmp089 = c_zero;\n\tt_position tmp002 = t_position(a_pos);\n\tfloat tmp085 = (u_params.v_width * tmp087);\n\tt_translation tmp044 = u_translation;\n\tfloat tmp058 = (tmp057 / tmp055);\n\tfloat tmp075 = (tmp070 + u_params.v_pillow_width);\n\tfloat tmp078 = (compute_modpre_translate(compute_modpre_rotate(tmp002.v_pos, tmp089.v_value, tmp044.v_rot_Y, tmp089.v_value).v_pos, vec3(tmp044.v_trans_X, tmp044.v_trans_Y, tmp044.v_trans_Z)).v_pos.x - tmp076);\n\tfloat tmp081 = (c_stdconsts.v_dotfive * ((u_params.v_pillow_width * c_stdconsts.v_ten) * u_params.v_pillow_shell));\n\tfloat tmp051 = (u_params.v_depth - u_params.v_armrest_width);\n\tfloat tmp059 = (u_params.v_back_width * tmp058);\n\tfloat tmp049 = (u_params.v_width - u_params.v_armrest_width);\n\tfloat tmp033 = opp(tmp048);\n\tvec3 tmp034 = compute_modpre_translate(compute_modpre_rotate(tmp002.v_pos, tmp089.v_value, tmp044.v_rot_Y, tmp089.v_value).v_pos, vec3(tmp044.v_trans_X, tmp044.v_trans_Y, tmp044.v_trans_Z)).v_pos;\n\tfloat tmp053 = (u_params.v_height + u_params.v_armrest_height);\n\tfloat tmp036 = abs(tmp034.x);\n\tfloat tmp037 = abs(tmp034.z);\n\tconst t_stdconsts tmp001 = c_stdconsts;\n\tfloat tmp039 = (tmp025 + u_params.v_back_width);\n\tfloat tmp084 = (tmp085 * u_params.v_pillow_spacing);\n\tfloat tmp054 = (tmp053 / tmp055);\n\tfloat tmp080 = (tmp075 + tmp081);\n\tfloat tmp079 = (tmp078 - u_params.v_pillow_depth);\n\tvec3 tmp043 = vec3(tmp044.v_trans_X, tmp044.v_trans_Y, tmp044.v_trans_Z);\n\tfloat tmp072 = abs(compute_modpre_translate(compute_modpre_rotate(tmp002.v_pos, tmp089.v_value, tmp044.v_rot_Y, tmp089.v_value).v_pos, tmp043).v_pos.z);\n\tfloat tmp050 = (u_params.v_width - u_params.v_armrest_width);\n\tt_modpre_rotate_outlet tmp088 = compute_modpre_rotate(tmp002.v_pos, tmp089.v_value, tmp044.v_rot_Y, tmp089.v_value);\n\tvec3 tmp068 = compute_modpre_translate(tmp088.v_pos, tmp043).v_pos;\n\tfloat tmp016 = opp(tmp049);\n\tfloat tmp073 = (tmp072 - tmp084);\n\tvec3 tmp035 = vec3(tmp036, tmp034.y, tmp037);\n\tfloat tmp099 = (u_params.v_armrest_height - (u_params.v_armrest_width * u_params.v_armrest_shell));\n\tfloat tmp069 = (tmp068.y - tmp080);\n\tfloat tmp056 = (tmp054 - tmp059);\n\tvec3 tmp032 = vec3(tmp051, tmp033, tmp050);\n\tt_modpre_translate_outlet tmp042 = compute_modpre_translate(tmp088.v_pos, tmp043);\n\tfloat tmp077 = (tmp079 + u_params.v_depth);\n\tfloat tmp097 = (u_params.v_width - (u_params.v_cushion_height * u_params.v_cushion_shell));\n\tvec3 tmp023 = vec3(tmp039, tmp053, c_stdconsts.v_zero);\n\tfloat tmp092 = (u_params.v_armrest_width - (u_params.v_armrest_width * u_params.v_armrest_shell));\n\tfloat tmp098 = (u_params.v_depth - (u_params.v_armrest_width * u_params.v_armrest_shell));\n\tvec3 tmp015 = vec3(tmp001.v_zero, u_params.v_armrest_height, tmp049);\n\tvec3 tmp046 = tmp042.v_pos;\n\tvec3 tmp009 = vec3(tmp001.v_zero, u_params.v_armrest_height, tmp016);\n\tfloat tmp096 = (u_params.v_depth - (u_params.v_cushion_height * u_params.v_cushion_shell));\n\tfloat tmp095 = (u_params.v_cushion_height - (u_params.v_cushion_height * u_params.v_cushion_shell));\n\tfloat tmp047 = (tmp046.y - u_params.v_cushion_height);\n\tfloat tmp102 = (u_params.v_back_width - (u_params.v_back_width * u_params.v_back_shell));\n\tvec3 tmp031 = (tmp035 - tmp032);\n\tconst t_stdconsts tmp071 = c_stdconsts;\n\tt_params tmp017 = u_params;\n\tvec3 tmp022 = (tmp042.v_pos - tmp023);\n\tconst t_stdconsts tmp029 = c_stdconsts;\n\tconst t_stdconsts tmp024 = c_stdconsts;\n\tvec3 tmp067 = vec3(tmp077, tmp069, tmp073);\n\tconst t_cyl_rot tmp040 = c_cyl_rot;\n\tfloat tmp065 = (u_params.v_pillow_depth - ((u_params.v_pillow_width * tmp071.v_ten) * u_params.v_pillow_shell));\n\tvec3 tmp006 = vec3(tmp098, tmp099, tmp092);\n\tvec3 tmp008 = (tmp042.v_pos - tmp009);\n\tfloat tmp104 = (u_params.v_width - (u_params.v_back_width * u_params.v_back_shell));\n\tvec3 tmp005 = vec3(tmp096, tmp095, tmp097);\n\tfloat tmp103 = (tmp056 - (u_params.v_back_width * u_params.v_back_shell));\n\tvec3 tmp045 = vec3(tmp046.x, tmp047, tmp046.z);\n\tvec3 tmp013 = (tmp042.v_pos - tmp015);\n\tt_params tmp004 = u_params;\n\tt_params tmp028 = u_params;\n\tt_params tmp020 = u_params;\n\tvec3 tmp062 = vec3(tmp065, u_params.v_pillow_width, u_params.v_pillow_width);\n\tfloat tmp082 = (u_params.v_pillow_width * tmp071.v_ten);\n\tvec3 tmp019 = vec3(tmp102, tmp103, tmp104);\n\tt_modpre_rotate_outlet tmp041 = compute_modpre_rotate(tmp031, tmp040.v_angle_X, tmp029.v_zero, tmp029.v_zero);\n\tt_modpre_rotate_outlet tmp052 = compute_modpre_rotate(tmp022, tmp024.v_zero, tmp024.v_zero, tmp020.v_back_angle);\n\tt_cube_outlet tmp012 = compute_cube(tmp013, tmp006);\n\tt_cube_outlet tmp011 = compute_cube(tmp008, tmp006);\n\tt_params tmp010 = u_params;\n\tfloat tmp030 = (tmp028.v_depth / tmp029.v_ten);\n\tt_cube_outlet tmp003 = compute_cube(tmp045, tmp005);\n\tfloat tmp094 = (tmp017.v_cushion_height * tmp017.v_cushion_shell);\n\tt_modpre_rotate_outlet tmp074 = compute_modpre_rotate(tmp067, tmp071.v_zero, tmp010.v_pillow_angle, tmp010.v_pillow_angle_back);\n\tt_cylinder_outlet tmp026 = compute_cylinder(tmp041.v_pos, tmp028.v_foot_height, tmp030);\n\tfloat tmp093 = (tmp003.v_dist - tmp094);\n\tt_cube_outlet tmp018 = compute_cube(tmp052.v_pos, tmp019);\n\tt_union_outlet tmp014 = compute_union(tmp011.v_dist, tmp012.v_dist);\n\tt_cube_outlet tmp063 = compute_cube(tmp074.v_pos, tmp062);\n\tfloat tmp083 = (tmp082 * tmp010.v_pillow_shell);\n\tfloat tmp091 = (tmp004.v_armrest_width * tmp004.v_armrest_shell);\n\tfloat tmp101 = (tmp020.v_back_width * tmp020.v_back_shell);\n\tt_union_outlet tmp027 = compute_union(tmp026.v_dist, tmp093);\n\tfloat tmp064 = (tmp063.v_dist - tmp083);\n\tfloat tmp090 = (tmp014.v_o0 - tmp091);\n\tfloat tmp100 = (tmp018.v_dist - tmp101);\n\tt_union_outlet tmp061 = compute_union(tmp090, tmp064);\n\tt_union_outlet tmp021 = compute_union(tmp027.v_o0, tmp100);\n\tt_union_outlet tmp007 = compute_union(tmp021.v_o0, tmp061.v_o0);\n\treturn t_outlet(tmp007.v_o0);\n}\n\nfloat eval_distance(vec3 pos) {\n\treturn compute_main_digraph(pos).v_dist;\n}\nvec3 eval_basecolor(vec3 pos) {\n\treturn vec3(-1.f);\n}\nfloat eval_roughness(vec3 pos) {\n\treturn -1.f;\n}\nfloat eval_metallic(vec3 pos) {\n\treturn -1.f;\n}\n", "table": "//// PREAMBLE\n\nfloat opp(float vv) { return -vv; }\n\nfloat vmin(vec2 vv) { return min(vv.x, vv.y); }\nfloat vmin(vec3 vv) { return min(min(vv.x, vv.y), vv.z); }\nfloat vmin(vec4 vv) { return min(min(vv.x, vv.y), min(vv.z, vv.w)); }\n\nfloat vmax(vec2 vv) { return max(vv.x, vv.y); }\nfloat vmax(vec3 vv) { return max(max(vv.x, vv.y), vv.z); }\nfloat vmax(vec4 vv) { return max(max(vv.x, vv.y), max(vv.z, vv.w)); }\n\n// According to the Kronos documentation, the fract of the input is computing\n// in this way 'x-floor(x)' which result to wrong results with negative values.\nfloat fractOfPositiveAndNegativeValue(float vv) {\n  return vv < 0.0 ? vv - ceil(vv) : vv - floor(vv);\n}\nvec2 fractOfPositiveAndNegativeValue(vec2 vv) {\n  return vec2(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y));\n}\nvec3 fractOfPositiveAndNegativeValue(vec3 vv) {\n  return vec3(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z));\n}\nvec4 fractOfPositiveAndNegativeValue(vec4 vv) {\n  return vec4(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z),\n    fractOfPositiveAndNegativeValue(vv.w));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n  float n = dot(i, step);\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec2 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec3 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n// https://www.pcg-random.org/\nfloat noisePcg(float q){\n  uint v = uint(round(q));\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float(float((word >> 22u) ^ word) * (1.0/float(0xffffffffu))) ;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh  \nvec2 noisePcg(vec2 q){\n  uvec2 v = uvec2(q);\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  return vec2(vec2(v)* (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec3 noisePcg(vec3 q){\n  uvec3 v = uvec3(q);\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  \n  return vec3(vec3(v) * (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec4 noisePcg(vec4 q){\n  uvec4 v = uvec4(q);\n  v = v * 1664525u + 1013904223u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  v ^= v >> 16u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  return vec4(vec4(v) * (1.0/float(0xffffffffu)));\n}\n\n\n//// CUSTOM TYPES\n\nstruct t_stdconsts {\n\tfloat v_zero;\n\tvec3 v_origin;\n\tfloat v_one;\n\tfloat v_dotfive;\n\tfloat v_two;\n\tfloat v_ten;\n};\n\nstruct t_translation {\n\tfloat v_trans_X;\n\tfloat v_trans_Y;\n\tfloat v_trans_Z;\n};\n\nstruct t_params {\n\tfloat v_width;\n\tfloat v_height;\n\tfloat v_depth;\n\tfloat v_thickness;\n\tfloat v_foot_thickness;\n\tfloat v_foot_shell;\n\tfloat v_foot_dist_edge;\n\tfloat v_table_shell;\n};\n\nstruct t_union_inlet {\n\tfloat v_a;\n\tfloat v_b;\n};\nstruct t_union_outlet {\n\tfloat v_o0;\n};\n\nstruct t_modpost_difference_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n};\nstruct t_modpost_difference_outlet {\n\tfloat v_dist;\n};\n\nstruct t_position {\n\tvec3 v_pos;\n};\nstruct t_outlet {\n\tfloat v_dist;\n};\n\nstruct t_cube_inlet {\n\tvec3 v_pos;\n\tvec3 v_size;\n};\nstruct t_cube_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpost_shell_inlet {\n\tfloat v_dist;\n\tfloat v_thickness;\n};\nstruct t_modpost_shell_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_translate_inlet {\n\tvec3 v_pos;\n\tvec3 v_offset;\n};\nstruct t_modpre_translate_outlet {\n\tvec3 v_pos;\n};\n\n//// PROTOTYPES\n\n// float operator-(float a_a, float a_b); // FUNCID(5) builtin arithmetic\n// float min(float a_a, float a_b); // FUNCID(48) builtin operator\n// float operator*(float a_a, float a_b); // FUNCID(40) builtin arithmetic\n// float operator+(float a_a, float a_b); // FUNCID(49) builtin arithmetic\n// float abs(float a_i); // FUNCID(52) builtin operator\n// float opp(float a_i); // FUNCID(28) builtin operator\n// vec3 operator-(vec3 a_a, vec3 a_b); // FUNCID(6) builtin arithmetic\n// float max(float a_a, float a_b); // FUNCID(32) builtin operator\n// vec3 abs(vec3 a_i); // FUNCID(26) builtin operator\n// float vmax(vec3 a_i); // FUNCID(95) builtin operator\n// vec3 max(vec3 a_a, vec3 a_b); // FUNCID(30) builtin operator\n// float length(vec3 a_i); // FUNCID(9) builtin operator\nt_union_outlet compute_union(float a_a, float a_b); // FUNCID(142) terminal\nt_modpost_difference_outlet compute_modpost_difference(float a_dist0, float a_dist1); // FUNCID(214) terminal\nt_outlet compute_main_digraph(vec3 a_pos); // FUNCID(152) terminal\nt_cube_outlet compute_cube(vec3 a_pos, vec3 a_size); // FUNCID(112) terminal\nt_modpost_shell_outlet compute_modpost_shell(float a_dist, float a_thickness); // FUNCID(211) terminal\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset); // FUNCID(204) terminal\n\n//// INSTANCES\n\nconst t_stdconsts c_stdconsts = t_stdconsts(float(0), vec3(0, 0, 0), float(1), float(0.5), float(2), float(10));\nuniform t_translation u_translation;\nuniform t_params u_params;\n\n//// IMPLEMENTATIONS\n\n// FUNCID(112) 2i->1o ComposeFuncType::Terminal [cube_inlet,cube_outlet,compute_cube]\n// ...\n// ...\nt_cube_outlet compute_cube(vec3 a_pos, vec3 a_size) {\n\tt_cube_inlet tmp007 = t_cube_inlet(a_pos, a_size);\n\tvec3 tmp005 = abs(tmp007.v_pos);\n\tvec3 tmp004 = (tmp005 - tmp007.v_size);\n\tconst t_stdconsts tmp001 = c_stdconsts;\n\tfloat tmp003 = vmax(tmp004);\n\tvec3 tmp002 = max(tmp004, tmp001.v_origin);\n\tfloat tmp009 = min(tmp003, tmp001.v_zero);\n\tfloat tmp000 = length(tmp002);\n\tfloat tmp008 = (tmp009 + tmp000);\n\treturn t_cube_outlet(tmp008);\n}\n\n// FUNCID(142) 2i->1o ComposeFuncType::Terminal [union_inlet,union_outlet,compute_union]\n// ...\n// ...\nt_union_outlet compute_union(float a_a, float a_b) {\n\tt_union_inlet tmp002 = t_union_inlet(a_a, a_b);\n\tfloat tmp000 = min(tmp002.v_a, tmp002.v_b);\n\treturn t_union_outlet(tmp000);\n}\n\n// FUNCID(204) 2i->1o ComposeFuncType::Terminal [modpre_translate_inlet,modpre_translate_outlet,compute_modpre_translate]\n// ...\n// ...\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset) {\n\tt_modpre_translate_inlet tmp002 = t_modpre_translate_inlet(a_pos, a_offset);\n\tvec3 tmp000 = (tmp002.v_pos - tmp002.v_offset);\n\treturn t_modpre_translate_outlet(tmp000);\n}\n\n// FUNCID(211) 2i->1o ComposeFuncType::Terminal [modpost_shell_inlet,modpost_shell_outlet,compute_modpost_shell]\n// ...\n// ...\nt_modpost_shell_outlet compute_modpost_shell(float a_dist, float a_thickness) {\n\tt_modpost_shell_inlet tmp003 = t_modpost_shell_inlet(a_dist, a_thickness);\n\tfloat tmp000 = (tmp003.v_dist - tmp003.v_thickness);\n\treturn t_modpost_shell_outlet(tmp000);\n}\n\n// FUNCID(214) 2i->1o ComposeFuncType::Terminal [modpost_difference_inlet,modpost_difference_outlet,compute_modpost_difference]\n// ...\n// ...\nt_modpost_difference_outlet compute_modpost_difference(float a_dist0, float a_dist1) {\n\tt_modpost_difference_inlet tmp003 = t_modpost_difference_inlet(a_dist0, a_dist1);\n\tfloat tmp001 = opp(tmp003.v_dist1);\n\tfloat tmp000 = max(tmp003.v_dist0, tmp001);\n\treturn t_modpost_difference_outlet(tmp000);\n}\n\n// FUNCID(152) 1i->1o ComposeFuncType::Terminal [position,outlet,compute_main_digraph]\n// ...\n// ...\nt_outlet compute_main_digraph(vec3 a_pos) {\n\tfloat tmp048 = min(u_params.v_width, u_params.v_depth);\n\tfloat tmp049 = (tmp048 * u_params.v_foot_dist_edge);\n\tt_translation tmp016 = u_translation;\n\tfloat tmp050 = (tmp049 - u_params.v_foot_thickness);\n\tfloat tmp025 = (u_params.v_depth - u_params.v_foot_thickness);\n\tfloat tmp024 = (u_params.v_width - u_params.v_foot_thickness);\n\tvec3 tmp010 = compute_modpre_translate(t_position(a_pos).v_pos, vec3(tmp016.v_trans_X, tmp016.v_trans_Y, tmp016.v_trans_Z)).v_pos;\n\tfloat tmp027 = (tmp025 - tmp050);\n\tfloat tmp013 = abs(tmp010.z);\n\tfloat tmp026 = (tmp024 - tmp050);\n\tvec3 tmp015 = vec3(tmp016.v_trans_X, tmp016.v_trans_Y, tmp016.v_trans_Z);\n\tt_position tmp001 = t_position(a_pos);\n\tfloat tmp039 = abs((vec3(abs(tmp010.x), tmp010.y, tmp013) - vec3(tmp027, opp(u_params.v_thickness), tmp026)).y);\n\tfloat tmp009 = opp(u_params.v_thickness);\n\tfloat tmp012 = abs(tmp010.x);\n\tfloat tmp037 = (tmp039 - u_params.v_height);\n\tconst t_stdconsts tmp040 = c_stdconsts;\n\tconst t_stdconsts tmp034 = c_stdconsts;\n\tt_modpre_translate_outlet tmp014 = compute_modpre_translate(tmp001.v_pos, tmp015);\n\tvec3 tmp011 = vec3(tmp012, tmp010.y, tmp013);\n\tvec3 tmp008 = vec3(tmp027, tmp009, tmp026);\n\tfloat tmp044 = (tmp040.v_ten - tmp040.v_two);\n\tfloat tmp023 = (u_params.v_foot_thickness - ((u_params.v_foot_thickness * u_params.v_foot_shell) * (tmp040.v_one + tmp040.v_two)));\n\tvec3 tmp036 = (tmp011 - tmp008);\n\tvec3 tmp018 = tmp014.v_pos;\n\tfloat tmp033 = (u_params.v_foot_thickness * tmp034.v_two);\n\tvec3 tmp021 = vec3(tmp023, u_params.v_height, tmp023);\n\tfloat tmp045 = (tmp044 - tmp040.v_one);\n\tfloat tmp038 = (tmp037 - tmp033);\n\tfloat tmp042 = (u_params.v_foot_thickness * u_params.v_foot_shell);\n\tvec3 tmp007 = (tmp011 - tmp008);\n\tfloat tmp029 = (u_params.v_thickness - ((tmp045 * u_params.v_thickness) * u_params.v_table_shell));\n\tfloat tmp041 = (tmp040.v_one + tmp040.v_two);\n\tt_params tmp006 = u_params;\n\tfloat tmp022 = (tmp018.y - u_params.v_height);\n\tt_params tmp004 = u_params;\n\tfloat tmp043 = (tmp042 * tmp041);\n\tt_cube_outlet tmp020 = compute_cube(tmp007, tmp021);\n\tvec3 tmp017 = vec3(tmp018.x, tmp022, tmp018.z);\n\tfloat tmp046 = (tmp045 * tmp004.v_thickness);\n\tvec3 tmp035 = vec3(tmp036.x, tmp038, tmp036.z);\n\tvec3 tmp031 = vec3(tmp006.v_foot_thickness, tmp033, tmp006.v_foot_thickness);\n\tvec3 tmp003 = vec3(tmp004.v_depth, tmp029, tmp004.v_width);\n\tfloat tmp047 = (tmp046 * tmp004.v_table_shell);\n\tt_modpost_shell_outlet tmp019 = compute_modpost_shell(tmp020.v_dist, tmp043);\n\tt_cube_outlet tmp030 = compute_cube(tmp035, tmp031);\n\tt_cube_outlet tmp002 = compute_cube(tmp017, tmp003);\n\tt_modpost_difference_outlet tmp032 = compute_modpost_difference(tmp019.v_dist, tmp030.v_dist);\n\tt_modpost_shell_outlet tmp028 = compute_modpost_shell(tmp002.v_dist, tmp047);\n\tt_union_outlet tmp005 = compute_union(tmp032.v_dist, tmp028.v_dist);\n\treturn t_outlet(tmp005.v_o0);\n}\n\nfloat eval_distance(vec3 pos) {\n\treturn compute_main_digraph(pos).v_dist;\n}\nvec3 eval_basecolor(vec3 pos) {\n\treturn vec3(-1.f);\n}\nfloat eval_roughness(vec3 pos) {\n\treturn -1.f;\n}\nfloat eval_metallic(vec3 pos) {\n\treturn -1.f;\n}\n", "mug": "//// PREAMBLE\n\nfloat opp(float vv) { return -vv; }\n\nfloat vmin(vec2 vv) { return min(vv.x, vv.y); }\nfloat vmin(vec3 vv) { return min(min(vv.x, vv.y), vv.z); }\nfloat vmin(vec4 vv) { return min(min(vv.x, vv.y), min(vv.z, vv.w)); }\n\nfloat vmax(vec2 vv) { return max(vv.x, vv.y); }\nfloat vmax(vec3 vv) { return max(max(vv.x, vv.y), vv.z); }\nfloat vmax(vec4 vv) { return max(max(vv.x, vv.y), max(vv.z, vv.w)); }\n\n// According to the Kronos documentation, the fract of the input is computing\n// in this way 'x-floor(x)' which result to wrong results with negative values.\nfloat fractOfPositiveAndNegativeValue(float vv) {\n  return vv < 0.0 ? vv - ceil(vv) : vv - floor(vv);\n}\nvec2 fractOfPositiveAndNegativeValue(vec2 vv) {\n  return vec2(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y));\n}\nvec3 fractOfPositiveAndNegativeValue(vec3 vv) {\n  return vec3(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z));\n}\nvec4 fractOfPositiveAndNegativeValue(vec4 vv) {\n  return vec4(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z),\n    fractOfPositiveAndNegativeValue(vv.w));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n  float n = dot(i, step);\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec2 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec3 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n// https://www.pcg-random.org/\nfloat noisePcg(float q){\n  uint v = uint(round(q));\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float(float((word >> 22u) ^ word) * (1.0/float(0xffffffffu))) ;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh  \nvec2 noisePcg(vec2 q){\n  uvec2 v = uvec2(q);\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  return vec2(vec2(v)* (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec3 noisePcg(vec3 q){\n  uvec3 v = uvec3(q);\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  \n  return vec3(vec3(v) * (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec4 noisePcg(vec4 q){\n  uvec4 v = uvec4(q);\n  v = v * 1664525u + 1013904223u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  v ^= v >> 16u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  return vec4(vec4(v) * (1.0/float(0xffffffffu)));\n}\n\n\n//// CUSTOM TYPES\n\nstruct t_consts {\n\tfloat v_cent;\n};\n\nstruct t_params {\n\tfloat v_radius;\n\tfloat v_thickness;\n\tfloat v_height;\n\tfloat v_handle_thickness;\n\tfloat v_handle_radius;\n\tfloat v_handle_angle;\n\tfloat v_handle_vertical;\n\tfloat v_handle_scale;\n\tfloat v_shell;\n\tfloat v_radius_bottom;\n\tfloat v_height_empty;\n};\n\nstruct t_half_pi {\n\tfloat v_value;\n};\n\nstruct t_zero {\n\tfloat v_value;\n};\n\nstruct t_translation {\n\tfloat v_trans_X;\n\tfloat v_trans_Y;\n\tfloat v_trans_Z;\n};\n\nstruct t_minus_one {\n\tfloat v_value;\n};\n\nstruct t_two {\n\tfloat v_value;\n};\n\nstruct t_half {\n\tfloat v_value;\n};\n\nstruct t_one {\n\tfloat v_value;\n};\n\nstruct t_pi {\n\tfloat v_value;\n};\n\nstruct t_eps {\n\tfloat v_eps;\n};\n\nstruct t_sdf_cone_inlet {\n\tvec3 v_pos;\n\tfloat v_height;\n\tfloat v_radius;\n};\nstruct t_sdf_cone_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpost_difference_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n};\nstruct t_modpost_difference_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpost_union_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n};\nstruct t_modpost_union_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_plane_inlet {\n\tvec3 v_pos;\n\tvec3 v_normal;\n\tfloat v_offset;\n};\nstruct t_sdf_plane_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_rotate_inlet {\n\tvec3 v_pos;\n\tfloat v_angle_x;\n\tfloat v_angle_y;\n\tfloat v_angle_z;\n};\nstruct t_modpre_rotate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_position {\n\tvec3 v_pos;\n};\nstruct t_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_cone_capped_inlet {\n\tvec3 v_pos;\n\tfloat v_height;\n\tfloat v_radius_large;\n\tfloat v_radius_small;\n};\nstruct t_sdf_cone_capped_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_torus_inlet {\n\tvec3 v_pos;\n\tfloat v_radius_major;\n\tfloat v_radius_minor;\n};\nstruct t_sdf_torus_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_difference_inlet {\n\tvec3 v_pos;\n};\nstruct t_modpre_difference_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\nstruct t_modpost_rotate_inlet {\n\tfloat v_dist;\n\tfloat v_angle_x;\n\tfloat v_angle_y;\n\tfloat v_angle_z;\n};\nstruct t_modpost_rotate_outlet {\n\tfloat v_dist;\n};\n\n//// PROTOTYPES\n\n// float min(float a_a, float a_b); // FUNCID(56) builtin operator\n// float operator-(float a_a, float a_b); // FUNCID(120) builtin arithmetic\n// float clamp(float a_x, float a_y, float a_z); // FUNCID(27) builtin operator\n// float operator/(float a_a, float a_b); // FUNCID(6) builtin arithmetic\n// float operator*(float a_a, float a_b); // FUNCID(113) builtin arithmetic\n// float sin(float a_i); // FUNCID(78) builtin operator\n// float operator+(float a_a, float a_b); // FUNCID(108) builtin arithmetic\n// float cos(float a_i); // FUNCID(32) builtin operator\n// float opp(float a_i); // FUNCID(18) builtin operator\n// vec2 operator-(vec2 a_a, vec2 a_b); // FUNCID(121) builtin arithmetic\n// vec3 operator+(vec3 a_a, vec3 a_b); // FUNCID(110) builtin arithmetic\n// float abs(float a_i); // FUNCID(4) builtin operator\n// vec3 normalize(vec3 a_i); // FUNCID(66) builtin operator\n// vec2 operator*(vec2 a_a, vec2 a_b); // FUNCID(114) builtin arithmetic\n// float max(float a_a, float a_b); // FUNCID(53) builtin operator\n// float length(vec2 a_i); // FUNCID(45) builtin operator\n// vec3 operator*(mat3 a_a, vec3 a_b); // FUNCID(112) builtin arithmetic\n// vec3 operator*(vec3 a_a, float a_b); // FUNCID(118) builtin arithmetic\n// float dot(vec3 a_a, vec3 a_b); // FUNCID(34) builtin operator\n// vec2 operator*(vec2 a_a, float a_b); // FUNCID(52) builtin arithmetic\n// float sqrt(float a_i); // FUNCID(83) builtin operator\n// float sign(float a_i); // FUNCID(74) builtin operator\n// float dot(vec2 a_a, vec2 a_b); // FUNCID(33) builtin operator\nt_sdf_cone_outlet compute_sdf_cone(vec3 a_pos, float a_height, float a_radius); // FUNCID(144) terminal\nt_modpost_difference_outlet compute_modpost_difference(float a_dist0, float a_dist1); // FUNCID(192) terminal\nt_modpost_union_outlet compute_modpost_union(float a_dist0, float a_dist1); // FUNCID(294) terminal\nt_sdf_plane_outlet compute_sdf_plane(vec3 a_pos, vec3 a_normal, float a_offset); // FUNCID(170) terminal\nt_modpre_rotate_outlet compute_modpre_rotate(vec3 a_pos, float a_angle_x, float a_angle_y, float a_angle_z); // FUNCID(242) terminal\nt_outlet compute_main_digraph(vec3 a_pos); // FUNCID(304) terminal\nt_sdf_cone_capped_outlet compute_sdf_cone_capped(vec3 a_pos, float a_height, float a_radius_large, float a_radius_small); // FUNCID(312) terminal\nt_sdf_torus_outlet compute_sdf_torus(vec3 a_pos, float a_radius_major, float a_radius_minor); // FUNCID(174) terminal\nt_modpre_difference_outlet compute_modpre_difference(vec3 a_pos); // FUNCID(189) terminal\nt_modpost_rotate_outlet compute_modpost_rotate(float a_dist, float a_angle_x, float a_angle_y, float a_angle_z); // FUNCID(245) terminal\n\n//// INSTANCES\n\nconst t_consts c_consts = t_consts(float(0.01));\nuniform t_params u_params;\nconst t_half_pi c_half_pi = t_half_pi(float(1.5707964));\nconst t_zero c_zero = t_zero(float(0));\nuniform t_translation u_translation;\nconst t_minus_one c_minus_one = t_minus_one(float(-1));\nconst t_two c_two = t_two(float(2));\nconst t_half c_half = t_half(float(0.5));\nconst t_one c_one = t_one(float(1));\nconst t_pi c_pi = t_pi(float(3.1415927));\nconst t_eps c_eps = t_eps(float(1e-08));\n\n//// IMPLEMENTATIONS\n\n// FUNCID(144) 3i->1o ComposeFuncType::Terminal [sdf_cone_inlet,sdf_cone_outlet,compute_sdf_cone]\n// ...\n// ...\nt_sdf_cone_outlet compute_sdf_cone(vec3 a_pos, float a_height, float a_radius) {\n\tfloat tmp010 = dot((vec2((t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), c_minus_one.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), vec2(length(vec2(t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.z)), (t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.y - t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height)));\n\tfloat tmp011 = dot((vec2((t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), c_minus_one.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), (vec2((t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), c_minus_one.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height));\n\tfloat tmp019 = (length(vec2(t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.z)) / (vec2((t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), c_minus_one.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height).x);\n\tfloat tmp020 = clamp(tmp019, c_zero.v_value, c_one.v_value);\n\tfloat tmp012 = (tmp010 / tmp011);\n\tconst t_one tmp015 = c_one;\n\tfloat tmp002 = (t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height);\n\tconst t_minus_one tmp003 = c_minus_one;\n\tconst t_zero tmp014 = c_zero;\n\tfloat tmp013 = clamp(tmp012, tmp014.v_value, tmp015.v_value);\n\tvec2 tmp021 = vec2(tmp020, tmp015.v_value);\n\tvec2 tmp004 = vec2(tmp002, tmp003.v_value);\n\tvec2 tmp007 = vec2(t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.z);\n\tt_sdf_cone_inlet tmp000 = t_sdf_cone_inlet(a_pos, a_height, a_radius);\n\tvec2 tmp005 = (tmp004 * tmp000.v_height);\n\tvec2 tmp016 = (tmp005 * tmp013);\n\tvec2 tmp009 = vec2(length(tmp007), (tmp000.v_pos.y - tmp000.v_height));\n\tfloat tmp008 = length(tmp007);\n\tvec3 tmp006 = tmp000.v_pos;\n\tvec2 tmp022 = (tmp005 * tmp021);\n\tvec2 tmp018 = tmp005;\n\tfloat tmp038 = (tmp006.y - tmp000.v_height);\n\tfloat tmp032 = (tmp018.x * tmp038);\n\tfloat tmp031 = (tmp008 * tmp018.y);\n\tvec2 tmp017 = (tmp009 - tmp016);\n\tvec2 tmp023 = (tmp009 - tmp022);\n\tfloat tmp025 = dot(tmp017, tmp017);\n\tfloat tmp026 = dot(tmp023, tmp023);\n\tfloat tmp028 = (tmp038 - tmp018.y);\n\tfloat tmp033 = (tmp031 - tmp032);\n\tfloat tmp024 = sign(tmp018.y);\n\tfloat tmp027 = min(tmp025, tmp026);\n\tfloat tmp029 = (tmp024 * tmp028);\n\tfloat tmp034 = (tmp024 * tmp033);\n\tconst t_eps tmp040 = c_eps;\n\tfloat tmp039 = (tmp027 + tmp040.v_eps);\n\tfloat tmp030 = max(tmp029, tmp034);\n\tfloat tmp036 = sqrt(tmp039);\n\tfloat tmp035 = sign(tmp030);\n\tfloat tmp037 = (tmp036 * tmp035);\n\treturn t_sdf_cone_outlet(tmp037);\n}\n\n// FUNCID(170) 3i->1o ComposeFuncType::Terminal [sdf_plane_inlet,sdf_plane_outlet,compute_sdf_plane]\n// ...\n// ...\nt_sdf_plane_outlet compute_sdf_plane(vec3 a_pos, vec3 a_normal, float a_offset) {\n\tvec3 tmp003 = normalize(t_sdf_plane_inlet(a_pos, a_normal, a_offset).v_normal);\n\tt_sdf_plane_inlet tmp000 = t_sdf_plane_inlet(a_pos, a_normal, a_offset);\n\tfloat tmp002 = dot(tmp000.v_pos, tmp003);\n\tfloat tmp004 = (tmp002 - tmp000.v_offset);\n\treturn t_sdf_plane_outlet(tmp004);\n}\n\n// FUNCID(189) 1i->2o ComposeFuncType::Terminal [modpre_difference_inlet,modpre_difference_outlet,compute_modpre_difference]\n// ...\n// ...\nt_modpre_difference_outlet compute_modpre_difference(vec3 a_pos) {\n\tconst t_one tmp002 = c_one;\n\tt_modpre_difference_inlet tmp000 = t_modpre_difference_inlet(a_pos);\n\tvec3 tmp003 = (tmp000.v_pos * tmp002.v_value);\n\treturn t_modpre_difference_outlet(tmp003, tmp003);\n}\n\n// FUNCID(192) 2i->1o ComposeFuncType::Terminal [modpost_difference_inlet,modpost_difference_outlet,compute_modpost_difference]\n// ...\n// ...\nt_modpost_difference_outlet compute_modpost_difference(float a_dist0, float a_dist1) {\n\tt_modpost_difference_inlet tmp000 = t_modpost_difference_inlet(a_dist0, a_dist1);\n\tfloat tmp002 = opp(tmp000.v_dist1);\n\tfloat tmp003 = max(tmp000.v_dist0, tmp002);\n\treturn t_modpost_difference_outlet(tmp003);\n}\n\n// FUNCID(242) 4i->1o ComposeFuncType::Terminal [modpre_rotate_inlet,modpre_rotate_outlet,compute_modpre_rotate]\n// ...\n// ...\nt_modpre_rotate_outlet compute_modpre_rotate(vec3 a_pos, float a_angle_x, float a_angle_y, float a_angle_z) {\n\tfloat tmp024 = (sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp020 = (sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp015 = (cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp011 = (cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp009 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_x);\n\tfloat tmp008 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_x);\n\tfloat tmp007 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y);\n\tfloat tmp005 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z);\n\tfloat tmp004 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z);\n\tfloat tmp006 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y);\n\tfloat tmp027 = (tmp005 * tmp009);\n\tfloat tmp025 = (tmp024 * tmp008);\n\tfloat tmp023 = (tmp005 * tmp008);\n\tfloat tmp021 = (tmp020 * tmp009);\n\tfloat tmp018 = (tmp004 * tmp009);\n\tfloat tmp016 = (tmp015 * tmp008);\n\tfloat tmp014 = (tmp004 * tmp008);\n\tfloat tmp012 = (tmp011 * tmp009);\n\tfloat tmp030 = (tmp006 * tmp008);\n\tfloat tmp029 = (tmp006 * tmp009);\n\tfloat tmp028 = opp(tmp007);\n\tfloat tmp026 = (tmp025 - tmp027);\n\tfloat tmp022 = (tmp021 + tmp023);\n\tfloat tmp019 = (tmp004 * tmp006);\n\tfloat tmp017 = (tmp016 + tmp018);\n\tfloat tmp013 = (tmp012 - tmp014);\n\tfloat tmp010 = (tmp005 * tmp006);\n\tt_modpre_rotate_inlet tmp000 = t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z);\n\tmat3 tmp002 = mat3(tmp010, tmp013, tmp017, tmp019, tmp022, tmp026, tmp028, tmp029, tmp030);\n\tvec3 tmp003 = (tmp002 * tmp000.v_pos);\n\treturn t_modpre_rotate_outlet(tmp003);\n}\n\n// FUNCID(245) 4i->1o ComposeFuncType::Terminal [modpost_rotate_inlet,modpost_rotate_outlet,compute_modpost_rotate]\n// ...\n// ...\nt_modpost_rotate_outlet compute_modpost_rotate(float a_dist, float a_angle_x, float a_angle_y, float a_angle_z) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_rotate_inlet tmp000 = t_modpost_rotate_inlet(a_dist, a_angle_x, a_angle_y, a_angle_z);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_rotate_outlet(tmp002);\n}\n\n// FUNCID(174) 3i->1o ComposeFuncType::Terminal [sdf_torus_inlet,sdf_torus_outlet,compute_sdf_torus]\n// ...\n// ...\nt_sdf_torus_outlet compute_sdf_torus(vec3 a_pos, float a_radius_major, float a_radius_minor) {\n\tvec2 tmp003 = vec2(t_sdf_torus_inlet(a_pos, a_radius_major, a_radius_minor).v_pos.x, t_sdf_torus_inlet(a_pos, a_radius_major, a_radius_minor).v_pos.z);\n\tfloat tmp005 = length(tmp003);\n\tvec3 tmp002 = t_sdf_torus_inlet(a_pos, a_radius_major, a_radius_minor).v_pos;\n\tfloat tmp004 = (tmp005 - t_sdf_torus_inlet(a_pos, a_radius_major, a_radius_minor).v_radius_major);\n\tvec2 tmp006 = vec2(tmp002.y, tmp004);\n\tt_sdf_torus_inlet tmp000 = t_sdf_torus_inlet(a_pos, a_radius_major, a_radius_minor);\n\tfloat tmp007 = length(tmp006);\n\tfloat tmp008 = (tmp007 - tmp000.v_radius_minor);\n\treturn t_sdf_torus_outlet(tmp008);\n}\n\n// FUNCID(294) 2i->1o ComposeFuncType::Terminal [modpost_union_inlet,modpost_union_outlet,compute_modpost_union]\n// ...\n// ...\nt_modpost_union_outlet compute_modpost_union(float a_dist0, float a_dist1) {\n\tt_modpost_union_inlet tmp000 = t_modpost_union_inlet(a_dist0, a_dist1);\n\tfloat tmp002 = min(tmp000.v_dist0, tmp000.v_dist1);\n\treturn t_modpost_union_outlet(tmp002);\n}\n\n// FUNCID(312) 4i->1o ComposeFuncType::Terminal [sdf_cone_capped_inlet,sdf_cone_capped_outlet,compute_sdf_cone_capped]\n// ...\n// ...\nt_sdf_cone_capped_outlet compute_sdf_cone_capped(vec3 a_pos, float a_height, float a_radius_large, float a_radius_small) {\n\tconst t_half tmp063 = c_half;\n\tconst t_half tmp062 = c_half;\n\tconst t_half tmp070 = c_half;\n\tfloat tmp060 = (tmp063.v_value * tmp062.v_value);\n\tfloat tmp078 = min(t_sdf_cone_capped_inlet(a_pos, a_height, a_radius_large, a_radius_small).v_radius_large, t_sdf_cone_capped_inlet(a_pos, a_height, a_radius_large, a_radius_small).v_radius_small);\n\tconst t_half tmp071 = c_half;\n\tfloat tmp061 = (tmp070.v_value * tmp060);\n\tfloat tmp077 = (tmp078 / t_sdf_cone_capped_inlet(a_pos, a_height, a_radius_large, a_radius_small).v_radius_large);\n\tconst t_one tmp076 = c_one;\n\tconst t_half tmp072 = c_half;\n\tfloat tmp068 = (tmp071.v_value * tmp061);\n\tfloat tmp075 = (tmp076.v_value - tmp077);\n\tfloat tmp069 = (tmp072.v_value * tmp068);\n\tconst t_two tmp058 = c_two;\n\tconst t_zero tmp006 = c_zero;\n\tfloat tmp059 = (tmp058.v_value * t_sdf_cone_capped_inlet(a_pos, a_height, a_radius_large, a_radius_small).v_height);\n\tvec3 tmp057 = t_sdf_cone_capped_inlet(a_pos, a_height, a_radius_large, a_radius_small).v_pos;\n\tconst t_pi tmp005 = c_pi;\n\tconst t_zero tmp066 = c_zero;\n\tfloat tmp073 = max(tmp075, tmp069);\n\tconst t_one tmp007 = c_one;\n\tfloat tmp004 = (tmp057.y - t_sdf_cone_capped_inlet(a_pos, a_height, a_radius_large, a_radius_small).v_height);\n\tt_sdf_cone_capped_inlet tmp080 = t_sdf_cone_capped_inlet(a_pos, a_height, a_radius_large, a_radius_small);\n\tvec3 tmp056 = vec3(tmp057.x, tmp004, tmp057.z);\n\tfloat tmp074 = (tmp059 / tmp073);\n\tvec3 tmp067 = vec3(tmp066.v_value, tmp007.v_value, tmp066.v_value);\n\tfloat tmp064 = opp(tmp059);\n\tt_modpre_rotate_outlet tmp000 = compute_modpre_rotate(tmp056, tmp005.v_value, tmp006.v_value, tmp006.v_value);\n\tt_sdf_plane_outlet tmp003 = compute_sdf_plane(tmp056, tmp067, tmp064);\n\tt_sdf_cone_outlet tmp001 = compute_sdf_cone(tmp000.v_pos, tmp074, tmp080.v_radius_large);\n\tt_modpost_difference_outlet tmp002 = compute_modpost_difference(tmp001.v_dist, tmp003.v_dist);\n\treturn t_sdf_cone_capped_outlet(tmp002.v_dist);\n}\n\n// FUNCID(304) 1i->1o ComposeFuncType::Terminal [position,outlet,compute_main_digraph]\n// ...\n// ...\nt_outlet compute_main_digraph(vec3 a_pos) {\n\tconst t_two tmp020 = c_two;\n\tfloat tmp014 = min(u_params.v_radius, u_params.v_radius_bottom);\n\tfloat tmp023 = (u_params.v_radius - tmp014);\n\tfloat tmp021 = (tmp020.v_value * u_params.v_height);\n\tconst t_half tmp015 = c_half;\n\tfloat tmp016 = (u_params.v_radius + tmp014);\n\tfloat tmp022 = (tmp023 / tmp021);\n\tfloat tmp017 = (tmp016 * tmp015.v_value);\n\tfloat tmp019 = (tmp022 * u_params.v_handle_vertical);\n\tfloat tmp040 = cos(u_params.v_handle_angle);\n\tfloat tmp043 = sin(u_params.v_handle_angle);\n\tfloat tmp018 = (tmp019 + tmp017);\n\tvec3 tmp051 = vec3((t_position(a_pos).v_pos + vec3(u_translation.v_trans_X, u_translation.v_trans_Y, u_translation.v_trans_Z)).x, ((t_position(a_pos).v_pos + vec3(u_translation.v_trans_X, u_translation.v_trans_Y, u_translation.v_trans_Z)).y - u_params.v_height), (t_position(a_pos).v_pos + vec3(u_translation.v_trans_X, u_translation.v_trans_Y, u_translation.v_trans_Z)).z);\n\tfloat tmp039 = (tmp018 * tmp043);\n\tfloat tmp041 = (tmp018 * tmp040);\n\tt_translation tmp036 = u_translation;\n\tfloat tmp038 = (tmp039 + tmp051.z);\n\tfloat tmp042 = (tmp041 + tmp051.x);\n\tfloat tmp006 = (u_params.v_handle_vertical - tmp051.y);\n\tconst t_zero tmp053 = c_zero;\n\tconst t_half_pi tmp054 = c_half_pi;\n\tconst t_consts tmp013 = c_consts;\n\tt_position tmp064 = t_position(a_pos);\n\tvec3 tmp035 = vec3(tmp036.v_trans_X, tmp036.v_trans_Y, tmp036.v_trans_Z);\n\tfloat tmp037 = opp(u_params.v_handle_angle);\n\tvec3 tmp050 = vec3(tmp042, tmp006, tmp038);\n\tfloat tmp048 = (u_params.v_height - u_params.v_handle_thickness);\n\tt_modpre_rotate_outlet tmp047 = compute_modpre_rotate(tmp050, tmp054.v_value, tmp037, tmp053.v_value);\n\tconst t_one tmp007 = c_one;\n\tvec3 tmp034 = (tmp064.v_pos + tmp035);\n\tfloat tmp032 = abs(u_params.v_handle_vertical);\n\tvec3 tmp059 = vec3(tmp034.x, (tmp034.y - u_params.v_height), tmp034.z);\n\tconst t_zero tmp011 = c_zero;\n\tfloat tmp005 = (tmp059.y - tmp013.v_cent);\n\tfloat tmp061 = (u_params.v_radius - u_params.v_thickness);\n\tfloat tmp010 = (u_params.v_height - u_params.v_height_empty);\n\tvec3 tmp012 = vec3(tmp011.v_value, tmp007.v_value, tmp011.v_value);\n\tvec3 tmp057 = tmp034;\n\tvec3 tmp058 = vec3(tmp059.x, tmp005, tmp059.z);\n\tvec3 tmp045 = tmp047.v_pos;\n\tfloat tmp033 = (tmp048 - tmp032);\n\tfloat tmp008 = (tmp057.y - u_params.v_height);\n\tfloat tmp024 = (u_params.v_radius_bottom - u_params.v_thickness);\n\tfloat tmp046 = (tmp045.x * u_params.v_handle_scale);\n\tt_params tmp062 = u_params;\n\tvec3 tmp044 = vec3(tmp046, tmp045.y, tmp045.z);\n\tfloat tmp052 = min(tmp033, tmp062.v_handle_radius);\n\tvec3 tmp056 = vec3(tmp057.x, tmp008, tmp057.z);\n\tt_sdf_cone_capped_outlet tmp003 = compute_sdf_cone_capped(tmp058, tmp062.v_height, tmp061, tmp024);\n\tt_sdf_plane_outlet tmp000 = compute_sdf_plane(tmp058, tmp012, tmp010);\n\tt_sdf_cone_capped_outlet tmp002 = compute_sdf_cone_capped(tmp056, tmp062.v_height, tmp062.v_radius, tmp062.v_radius_bottom);\n\tt_modpost_difference_outlet tmp004 = compute_modpost_difference(tmp003.v_dist, tmp000.v_dist);\n\tt_sdf_torus_outlet tmp001 = compute_sdf_torus(tmp044, tmp052, tmp062.v_handle_thickness);\n\tt_modpost_difference_outlet tmp060 = compute_modpost_difference(tmp002.v_dist, tmp004.v_dist);\n\tt_modpost_difference_outlet tmp049 = compute_modpost_difference(tmp001.v_dist, tmp002.v_dist);\n\tt_modpost_union_outlet tmp055 = compute_modpost_union(tmp060.v_dist, tmp049.v_dist);\n\treturn t_outlet(tmp055.v_dist);\n}\n\nfloat eval_distance(vec3 pos) {\n\treturn compute_main_digraph(pos).v_dist;\n}\nvec3 eval_basecolor(vec3 pos) {\n\treturn vec3(-1.f);\n}\nfloat eval_roughness(vec3 pos) {\n\treturn -1.f;\n}\nfloat eval_metallic(vec3 pos) {\n\treturn -1.f;\n}\n", "airplane_simple": "//// PREAMBLE\n\nfloat opp(float vv) { return -vv; }\n\nfloat vmin(vec2 vv) { return min(vv.x, vv.y); }\nfloat vmin(vec3 vv) { return min(min(vv.x, vv.y), vv.z); }\nfloat vmin(vec4 vv) { return min(min(vv.x, vv.y), min(vv.z, vv.w)); }\n\nfloat vmax(vec2 vv) { return max(vv.x, vv.y); }\nfloat vmax(vec3 vv) { return max(max(vv.x, vv.y), vv.z); }\nfloat vmax(vec4 vv) { return max(max(vv.x, vv.y), max(vv.z, vv.w)); }\n\n// According to the Kronos documentation, the fract of the input is computing\n// in this way 'x-floor(x)' which result to wrong results with negative values.\nfloat fractOfPositiveAndNegativeValue(float vv) {\n  return vv < 0.0 ? vv - ceil(vv) : vv - floor(vv);\n}\nvec2 fractOfPositiveAndNegativeValue(vec2 vv) {\n  return vec2(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y));\n}\nvec3 fractOfPositiveAndNegativeValue(vec3 vv) {\n  return vec3(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z));\n}\nvec4 fractOfPositiveAndNegativeValue(vec4 vv) {\n  return vec4(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z),\n    fractOfPositiveAndNegativeValue(vv.w));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n  float n = dot(i, step);\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec2 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec3 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n// https://www.pcg-random.org/\nfloat noisePcg(float q){\n  uint v = uint(round(q));\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float(float((word >> 22u) ^ word) * (1.0/float(0xffffffffu))) ;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh  \nvec2 noisePcg(vec2 q){\n  uvec2 v = uvec2(q);\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  return vec2(vec2(v)* (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec3 noisePcg(vec3 q){\n  uvec3 v = uvec3(q);\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  \n  return vec3(vec3(v) * (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec4 noisePcg(vec4 q){\n  uvec4 v = uvec4(q);\n  v = v * 1664525u + 1013904223u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  v ^= v >> 16u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  return vec4(vec4(v) * (1.0/float(0xffffffffu)));\n}\n\n\n//// CUSTOM TYPES\n\nstruct t_half_pi {\n\tfloat v_value;\n};\n\nstruct t_params {\n\tfloat v_body_radius;\n\tfloat v_body_length;\n\tfloat v_nose_length;\n\tfloat v_tail_length;\n\tfloat v_wings_pos;\n\tfloat v_wings_length;\n\tfloat v_wings_width;\n\tfloat v_wings_thickness;\n\tfloat v_wings_angle;\n\tfloat v_stab_h_length;\n\tfloat v_stab_h_width;\n\tfloat v_stab_v_height;\n\tfloat v_stab_v_width;\n};\n\nstruct t_zero {\n\tfloat v_value;\n};\n\nstruct t_consts {\n\tfloat v_stab_pos;\n\tfloat v_stab_thickness;\n};\n\nstruct t_translation {\n\tfloat v_trans_X;\n\tfloat v_trans_Y;\n\tfloat v_trans_Z;\n\tfloat v_rot_Y;\n};\n\nstruct t_one {\n\tfloat v_value;\n};\n\nstruct t_minus_one {\n\tfloat v_value;\n};\n\nstruct t_modpre_rotate_inlet {\n\tvec3 v_pos;\n\tfloat v_angle_x;\n\tfloat v_angle_y;\n\tfloat v_angle_z;\n};\nstruct t_modpre_rotate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_union_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n};\nstruct t_modpost_union_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_cylinder_inlet {\n\tvec3 v_pos;\n\tfloat v_height;\n\tfloat v_radius;\n};\nstruct t_sdf_cylinder_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_box_inlet {\n\tvec3 v_pos;\n\tvec3 v_bounding_box;\n};\nstruct t_sdf_box_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_cone_inlet {\n\tvec3 v_pos;\n\tfloat v_height;\n\tfloat v_radius;\n};\nstruct t_sdf_cone_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpost_translate_inlet {\n\tfloat v_dist;\n\tvec3 v_offset;\n};\nstruct t_modpost_translate_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_translate_inlet {\n\tvec3 v_pos;\n\tvec3 v_offset;\n};\nstruct t_modpre_translate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_rotate_inlet {\n\tfloat v_dist;\n\tfloat v_angle_x;\n\tfloat v_angle_y;\n\tfloat v_angle_z;\n};\nstruct t_modpost_rotate_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_union_inlet {\n\tvec3 v_pos;\n};\nstruct t_modpre_union_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\nstruct t_position {\n\tvec3 v_pos;\n};\nstruct t_outlet {\n\tfloat v_dist;\n};\n\n//// PROTOTYPES\n\n// float sign(float a_i); // FUNCID(94) builtin operator\n// float opp(float a_i); // FUNCID(84) builtin operator\n// vec3 max(vec3 a_a, vec3 a_b); // FUNCID(67) builtin operator\n// vec2 abs(vec2 a_i); // FUNCID(3) builtin operator\n// float operator*(float a_a, float a_b); // FUNCID(131) builtin arithmetic\n// float sin(float a_i); // FUNCID(98) builtin operator\n// float operator+(float a_a, float a_b); // FUNCID(126) builtin arithmetic\n// float length(vec2 a_i); // FUNCID(58) builtin operator\n// vec2 max(vec2 a_a, vec2 a_b); // FUNCID(61) builtin operator\n// float min(float a_a, float a_b); // FUNCID(69) builtin operator\n// float vmax(vec2 a_i); // FUNCID(90) builtin operator\n// vec3 abs(vec3 a_i); // FUNCID(11) builtin operator\n// vec2 operator-(vec2 a_a, vec2 a_b); // FUNCID(139) builtin arithmetic\n// float sqrt(float a_i); // FUNCID(103) builtin operator\n// vec3 operator*(mat3 a_a, vec3 a_b); // FUNCID(130) builtin arithmetic\n// float max(float a_a, float a_b); // FUNCID(66) builtin operator\n// float length(vec3 a_i); // FUNCID(59) builtin operator\n// vec3 operator-(vec3 a_a, vec3 a_b); // FUNCID(140) builtin arithmetic\n// float operator-(float a_a, float a_b); // FUNCID(138) builtin arithmetic\n// float cos(float a_i); // FUNCID(37) builtin operator\n// float dot(vec2 a_a, vec2 a_b); // FUNCID(38) builtin operator\n// vec2 operator*(vec2 a_a, vec2 a_b); // FUNCID(132) builtin arithmetic\n// float clamp(float a_x, float a_y, float a_z); // FUNCID(31) builtin operator\n// float operator/(float a_a, float a_b); // FUNCID(6) builtin arithmetic\n// vec2 operator*(vec2 a_a, float a_b); // FUNCID(65) builtin arithmetic\n// vec3 operator*(vec3 a_a, float a_b); // FUNCID(136) builtin arithmetic\nt_modpre_rotate_outlet compute_modpre_rotate(vec3 a_pos, float a_angle_x, float a_angle_y, float a_angle_z); // FUNCID(293) terminal\nt_modpost_union_outlet compute_modpost_union(float a_dist0, float a_dist1); // FUNCID(166) terminal\nt_sdf_cylinder_outlet compute_sdf_cylinder(vec3 a_pos, float a_height, float a_radius); // FUNCID(230) terminal\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box); // FUNCID(206) terminal\nt_sdf_cone_outlet compute_sdf_cone(vec3 a_pos, float a_height, float a_radius); // FUNCID(218) terminal\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset); // FUNCID(289) terminal\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset); // FUNCID(286) terminal\nt_modpost_rotate_outlet compute_modpost_rotate(float a_dist, float a_angle_x, float a_angle_y, float a_angle_z); // FUNCID(296) terminal\nt_modpre_union_outlet compute_modpre_union(vec3 a_pos); // FUNCID(163) terminal\nt_outlet compute_main_digraph(vec3 a_pos); // FUNCID(422) terminal\n\n//// INSTANCES\n\nconst t_half_pi c_half_pi = t_half_pi(float(1.5707964));\nuniform t_params u_params;\nconst t_zero c_zero = t_zero(float(0));\nconst t_consts c_consts = t_consts(float(-0.8), float(0.005));\nuniform t_translation u_translation;\nconst t_one c_one = t_one(float(1));\nconst t_minus_one c_minus_one = t_minus_one(float(-1));\n\n//// IMPLEMENTATIONS\n\n// FUNCID(163) 1i->2o ComposeFuncType::Terminal [modpre_union_inlet,modpre_union_outlet,compute_modpre_union]\n// ...\n// ...\nt_modpre_union_outlet compute_modpre_union(vec3 a_pos) {\n\tt_modpre_union_inlet tmp003 = t_modpre_union_inlet(a_pos);\n\tconst t_one tmp001 = c_one;\n\tvec3 tmp000 = (tmp003.v_pos * tmp001.v_value);\n\treturn t_modpre_union_outlet(tmp000, tmp000);\n}\n\n// FUNCID(166) 2i->1o ComposeFuncType::Terminal [modpost_union_inlet,modpost_union_outlet,compute_modpost_union]\n// ...\n// ...\nt_modpost_union_outlet compute_modpost_union(float a_dist0, float a_dist1) {\n\tt_modpost_union_inlet tmp002 = t_modpost_union_inlet(a_dist0, a_dist1);\n\tfloat tmp000 = min(tmp002.v_dist0, tmp002.v_dist1);\n\treturn t_modpost_union_outlet(tmp000);\n}\n\n// FUNCID(206) 2i->1o ComposeFuncType::Terminal [sdf_box_inlet,sdf_box_outlet,compute_sdf_box]\n// ...\n// ...\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box) {\n\tconst t_zero tmp006 = c_zero;\n\tt_sdf_box_inlet tmp000 = t_sdf_box_inlet(a_pos, a_bounding_box);\n\tvec3 tmp002 = abs(tmp000.v_pos);\n\tvec3 tmp004 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp003 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp008 = vec3(tmp006.v_value, tmp006.v_value, tmp006.v_value);\n\tfloat tmp005 = max(tmp004.y, tmp004.z);\n\tconst t_zero tmp012 = c_zero;\n\tfloat tmp010 = max(tmp004.x, tmp005);\n\tvec3 tmp007 = max(tmp008, tmp003);\n\tfloat tmp011 = min(tmp012.v_value, tmp010);\n\tfloat tmp009 = length(tmp007);\n\tfloat tmp013 = (tmp009 + tmp011);\n\treturn t_sdf_box_outlet(tmp013);\n}\n\n// FUNCID(218) 3i->1o ComposeFuncType::Terminal [sdf_cone_inlet,sdf_cone_outlet,compute_sdf_cone]\n// ...\n// ...\nt_sdf_cone_outlet compute_sdf_cone(vec3 a_pos, float a_height, float a_radius) {\n\tfloat tmp019 = (length(vec2(t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.z)) / (vec2((t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), c_minus_one.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height).x);\n\tfloat tmp002 = (t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height);\n\tconst t_minus_one tmp003 = c_minus_one;\n\tfloat tmp010 = dot((vec2(tmp002, tmp003.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), vec2(length(vec2(t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.z)), (t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.y - t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height)));\n\tfloat tmp011 = dot((vec2(tmp002, tmp003.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), (vec2(tmp002, tmp003.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height));\n\tvec2 tmp004 = vec2(tmp002, tmp003.v_value);\n\tfloat tmp020 = clamp(tmp019, c_zero.v_value, c_one.v_value);\n\tconst t_one tmp015 = c_one;\n\tvec2 tmp007 = vec2(t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.z);\n\tfloat tmp012 = (tmp010 / tmp011);\n\tconst t_zero tmp014 = c_zero;\n\tt_sdf_cone_inlet tmp000 = t_sdf_cone_inlet(a_pos, a_height, a_radius);\n\tfloat tmp013 = clamp(tmp012, tmp014.v_value, tmp015.v_value);\n\tvec3 tmp006 = tmp000.v_pos;\n\tvec2 tmp021 = vec2(tmp020, tmp015.v_value);\n\tvec2 tmp005 = (tmp004 * tmp000.v_height);\n\tfloat tmp008 = length(tmp007);\n\tvec2 tmp018 = tmp005;\n\tfloat tmp038 = (tmp006.y - tmp000.v_height);\n\tvec2 tmp009 = vec2(tmp008, tmp038);\n\tvec2 tmp022 = (tmp005 * tmp021);\n\tfloat tmp031 = (tmp008 * tmp018.y);\n\tfloat tmp032 = (tmp018.x * tmp038);\n\tvec2 tmp016 = (tmp005 * tmp013);\n\tfloat tmp024 = sign(tmp018.y);\n\tvec2 tmp023 = (tmp009 - tmp022);\n\tfloat tmp033 = (tmp031 - tmp032);\n\tfloat tmp028 = (tmp038 - tmp018.y);\n\tvec2 tmp017 = (tmp009 - tmp016);\n\tfloat tmp026 = dot(tmp023, tmp023);\n\tfloat tmp025 = dot(tmp017, tmp017);\n\tfloat tmp029 = (tmp024 * tmp028);\n\tfloat tmp034 = (tmp024 * tmp033);\n\tfloat tmp027 = min(tmp025, tmp026);\n\tfloat tmp030 = max(tmp029, tmp034);\n\tfloat tmp035 = sign(tmp030);\n\tfloat tmp036 = sqrt(tmp027);\n\tfloat tmp037 = (tmp036 * tmp035);\n\treturn t_sdf_cone_outlet(tmp037);\n}\n\n// FUNCID(230) 3i->1o ComposeFuncType::Terminal [sdf_cylinder_inlet,sdf_cylinder_outlet,compute_sdf_cylinder]\n// ...\n// ...\nt_sdf_cylinder_outlet compute_sdf_cylinder(vec3 a_pos, float a_height, float a_radius) {\n\tvec2 tmp003 = vec2(t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos.z);\n\tvec3 tmp002 = t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos;\n\tfloat tmp004 = length(tmp003);\n\tt_sdf_cylinder_inlet tmp000 = t_sdf_cylinder_inlet(a_pos, a_height, a_radius);\n\tvec2 tmp006 = vec2(tmp004, tmp002.y);\n\tvec2 tmp007 = abs(tmp006);\n\tvec2 tmp005 = vec2(tmp000.v_radius, tmp000.v_height);\n\tvec2 tmp008 = (tmp007 - tmp005);\n\tvec2 tmp013 = vec2(c_zero.v_value, c_zero.v_value);\n\tconst t_zero tmp010 = c_zero;\n\tvec2 tmp012 = max(tmp008, tmp013);\n\tfloat tmp009 = vmax(tmp008);\n\tfloat tmp015 = length(tmp012);\n\tfloat tmp011 = min(tmp009, tmp010.v_value);\n\tfloat tmp014 = (tmp011 + tmp015);\n\treturn t_sdf_cylinder_outlet(tmp014);\n}\n\n// FUNCID(286) 2i->1o ComposeFuncType::Terminal [modpre_translate_inlet,modpre_translate_outlet,compute_modpre_translate]\n// ...\n// ...\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset) {\n\tt_modpre_translate_inlet tmp000 = t_modpre_translate_inlet(a_pos, a_offset);\n\tvec3 tmp002 = (tmp000.v_pos - tmp000.v_offset);\n\treturn t_modpre_translate_outlet(tmp002);\n}\n\n// FUNCID(289) 2i->1o ComposeFuncType::Terminal [modpost_translate_inlet,modpost_translate_outlet,compute_modpost_translate]\n// ...\n// ...\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_translate_inlet tmp000 = t_modpost_translate_inlet(a_dist, a_offset);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_translate_outlet(tmp002);\n}\n\n// FUNCID(293) 4i->1o ComposeFuncType::Terminal [modpre_rotate_inlet,modpre_rotate_outlet,compute_modpre_rotate]\n// ...\n// ...\nt_modpre_rotate_outlet compute_modpre_rotate(vec3 a_pos, float a_angle_x, float a_angle_y, float a_angle_z) {\n\tfloat tmp024 = (sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp020 = (sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp015 = (cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp011 = (cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp009 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_x);\n\tfloat tmp008 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_x);\n\tfloat tmp007 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y);\n\tfloat tmp005 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z);\n\tfloat tmp004 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z);\n\tfloat tmp006 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y);\n\tfloat tmp027 = (tmp005 * tmp009);\n\tfloat tmp025 = (tmp024 * tmp008);\n\tfloat tmp023 = (tmp005 * tmp008);\n\tfloat tmp021 = (tmp020 * tmp009);\n\tfloat tmp018 = (tmp004 * tmp009);\n\tfloat tmp016 = (tmp015 * tmp008);\n\tfloat tmp014 = (tmp004 * tmp008);\n\tfloat tmp012 = (tmp011 * tmp009);\n\tfloat tmp030 = (tmp006 * tmp008);\n\tfloat tmp029 = (tmp006 * tmp009);\n\tfloat tmp028 = opp(tmp007);\n\tfloat tmp026 = (tmp025 - tmp027);\n\tfloat tmp022 = (tmp021 + tmp023);\n\tfloat tmp019 = (tmp004 * tmp006);\n\tfloat tmp017 = (tmp016 + tmp018);\n\tfloat tmp013 = (tmp012 - tmp014);\n\tfloat tmp010 = (tmp005 * tmp006);\n\tt_modpre_rotate_inlet tmp000 = t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z);\n\tmat3 tmp002 = mat3(tmp010, tmp013, tmp017, tmp019, tmp022, tmp026, tmp028, tmp029, tmp030);\n\tvec3 tmp003 = (tmp002 * tmp000.v_pos);\n\treturn t_modpre_rotate_outlet(tmp003);\n}\n\n// FUNCID(296) 4i->1o ComposeFuncType::Terminal [modpost_rotate_inlet,modpost_rotate_outlet,compute_modpost_rotate]\n// ...\n// ...\nt_modpost_rotate_outlet compute_modpost_rotate(float a_dist, float a_angle_x, float a_angle_y, float a_angle_z) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_rotate_inlet tmp000 = t_modpost_rotate_inlet(a_dist, a_angle_x, a_angle_y, a_angle_z);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_rotate_outlet(tmp002);\n}\n\n// FUNCID(422) 1i->1o ComposeFuncType::Terminal [position,outlet,compute_main_digraph]\n// ...\n// ...\nt_outlet compute_main_digraph(vec3 a_pos) {\n\tt_modpre_union_outlet tmp065 = compute_modpre_union(compute_modpre_union(compute_modpre_union(compute_modpre_union(compute_modpre_rotate(compute_modpre_translate(t_position(a_pos).v_pos, vec3(u_translation.v_trans_X, u_translation.v_trans_Y, u_translation.v_trans_Z)).v_pos, c_zero.v_value, u_translation.v_rot_Y, c_zero.v_value).v_pos).v_pos0).v_pos0).v_pos1);\n\tt_modpre_union_outlet tmp059 = compute_modpre_union(compute_modpre_union(compute_modpre_union(compute_modpre_rotate(compute_modpre_translate(t_position(a_pos).v_pos, vec3(u_translation.v_trans_X, u_translation.v_trans_Y, u_translation.v_trans_Z)).v_pos, c_zero.v_value, u_translation.v_rot_Y, c_zero.v_value).v_pos).v_pos0).v_pos0);\n\tt_modpre_translate_outlet tmp073 = compute_modpre_translate(tmp065.v_pos1, vec3((u_params.v_body_length * u_params.v_wings_pos), c_zero.v_value, c_zero.v_value));\n\tt_modpre_translate_outlet tmp071 = compute_modpre_translate(tmp065.v_pos0, vec3((u_params.v_body_length * u_params.v_wings_pos), c_zero.v_value, c_zero.v_value));\n\tt_modpre_union_outlet tmp063 = compute_modpre_union(tmp059.v_pos0);\n\tt_modpre_rotate_outlet tmp083 = compute_modpre_rotate(tmp073.v_pos, c_zero.v_value, opp(u_params.v_wings_angle), c_zero.v_value);\n\tt_modpre_rotate_outlet tmp081 = compute_modpre_rotate(tmp071.v_pos, c_zero.v_value, u_params.v_wings_angle, c_zero.v_value);\n\tt_modpre_translate_outlet tmp077 = compute_modpre_translate(compute_modpre_union(tmp063.v_pos0).v_pos1, vec3(u_params.v_body_length, c_zero.v_value, c_zero.v_value));\n\tconst t_half_pi tmp039 = c_half_pi;\n\tconst t_zero tmp028 = c_zero;\n\tt_modpre_translate_outlet tmp089 = compute_modpre_translate(tmp083.v_pos, vec3(tmp028.v_value, tmp028.v_value, u_params.v_wings_length));\n\tt_modpre_rotate_outlet tmp085 = compute_modpre_rotate(tmp077.v_pos, c_zero.v_value, c_zero.v_value, opp(tmp039.v_value));\n\tt_modpre_union_outlet tmp067 = compute_modpre_union(tmp063.v_pos0);\n\tconst t_zero tmp022 = c_zero;\n\tvec3 tmp031 = vec3(u_params.v_wings_width, u_params.v_wings_thickness, u_params.v_wings_length);\n\tt_modpre_translate_outlet tmp087 = compute_modpre_translate(tmp081.v_pos, vec3(tmp022.v_value, tmp022.v_value, opp(u_params.v_wings_length)));\n\tt_modpre_translate_outlet tmp069 = compute_modpre_translate(tmp063.v_pos1, vec3(opp(u_params.v_body_length), c_zero.v_value, c_zero.v_value));\n\tfloat tmp021 = opp(u_params.v_wings_length);\n\tt_params tmp033 = u_params;\n\tconst t_zero tmp040 = c_zero;\n\tfloat tmp025 = opp(tmp039.v_value);\n\tt_sdf_box_outlet tmp091 = compute_sdf_box(tmp087.v_pos, tmp031);\n\tt_sdf_box_outlet tmp090 = compute_sdf_box(tmp089.v_pos, tmp031);\n\tt_params tmp034 = u_params;\n\tvec3 tmp029 = vec3(tmp028.v_value, tmp028.v_value, u_params.v_wings_length);\n\tt_position tmp047 = t_position(a_pos);\n\tt_params tmp043 = u_params;\n\tconst t_zero tmp041 = c_zero;\n\tvec3 tmp023 = vec3(tmp022.v_value, tmp022.v_value, tmp021);\n\tt_sdf_cone_outlet tmp092 = compute_sdf_cone(tmp085.v_pos, tmp034.v_nose_length, tmp034.v_body_radius);\n\tt_modpre_rotate_outlet tmp079 = compute_modpre_rotate(tmp069.v_pos, c_zero.v_value, c_zero.v_value, c_half_pi.v_value);\n\tt_modpre_rotate_outlet tmp075 = compute_modpre_rotate(tmp067.v_pos0, c_zero.v_value, c_zero.v_value, c_half_pi.v_value);\n\tt_modpre_translate_outlet tmp049 = compute_modpre_translate(tmp047.v_pos, vec3(u_translation.v_trans_X, u_translation.v_trans_Y, u_translation.v_trans_Z));\n\tfloat tmp027 = opp(u_params.v_wings_angle);\n\tt_modpost_translate_outlet tmp088 = compute_modpost_translate(tmp090.v_dist, tmp029);\n\tt_sdf_cone_outlet tmp093 = compute_sdf_cone(tmp079.v_pos, tmp033.v_tail_length, tmp033.v_body_radius);\n\tt_sdf_cylinder_outlet tmp094 = compute_sdf_cylinder(tmp075.v_pos, tmp043.v_body_length, tmp043.v_body_radius);\n\tconst t_zero tmp044 = c_zero;\n\tt_modpost_translate_outlet tmp086 = compute_modpost_translate(tmp091.v_dist, tmp023);\n\tt_modpost_rotate_outlet tmp084 = compute_modpost_rotate(tmp092.v_dist, tmp040.v_value, tmp040.v_value, tmp025);\n\tconst t_zero tmp036 = c_zero;\n\tconst t_zero tmp030 = c_zero;\n\tconst t_half_pi tmp045 = c_half_pi;\n\tvec3 tmp042 = vec3(tmp034.v_body_length, tmp041.v_value, tmp041.v_value);\n\tfloat tmp026 = opp(tmp033.v_body_length);\n\tconst t_zero tmp037 = c_zero;\n\tconst t_half_pi tmp035 = c_half_pi;\n\tt_params tmp032 = u_params;\n\tconst t_zero tmp019 = c_zero;\n\tfloat tmp018 = (tmp032.v_body_length * tmp032.v_wings_pos);\n\tconst t_zero tmp024 = c_zero;\n\tconst t_consts tmp012 = c_consts;\n\tt_modpost_rotate_outlet tmp078 = compute_modpost_rotate(tmp093.v_dist, tmp036.v_value, tmp036.v_value, tmp035.v_value);\n\tt_modpre_rotate_outlet tmp051 = compute_modpre_rotate(tmp049.v_pos, c_zero.v_value, u_translation.v_rot_Y, c_zero.v_value);\n\tt_modpost_rotate_outlet tmp082 = compute_modpost_rotate(tmp088.v_dist, tmp030.v_value, tmp027, tmp030.v_value);\n\tt_params tmp017 = u_params;\n\tvec3 tmp020 = vec3(tmp018, tmp019.v_value, tmp019.v_value);\n\tt_modpost_rotate_outlet tmp074 = compute_modpost_rotate(tmp094.v_dist, tmp044.v_value, tmp044.v_value, tmp045.v_value);\n\tt_modpre_union_outlet tmp055 = compute_modpre_union(compute_modpre_union(tmp051.v_pos).v_pos0);\n\tt_modpost_rotate_outlet tmp080 = compute_modpost_rotate(tmp086.v_dist, tmp024.v_value, tmp032.v_wings_angle, tmp024.v_value);\n\tvec3 tmp038 = vec3(tmp026, tmp037.v_value, tmp037.v_value);\n\tt_modpost_translate_outlet tmp076 = compute_modpost_translate(tmp084.v_dist, tmp042);\n\tt_modpre_translate_outlet tmp061 = compute_modpre_translate(tmp055.v_pos1, vec3((tmp017.v_body_length * tmp012.v_stab_pos), c_zero.v_value, c_zero.v_value));\n\tt_modpre_union_outlet tmp053 = compute_modpre_union(tmp051.v_pos);\n\tt_modpost_translate_outlet tmp072 = compute_modpost_translate(tmp082.v_dist, tmp020);\n\tvec3 tmp016 = vec3(tmp017.v_stab_h_width, tmp012.v_stab_thickness, tmp017.v_stab_h_length);\n\tconst t_consts tmp006 = c_consts;\n\tfloat tmp013 = (tmp017.v_body_length * tmp012.v_stab_pos);\n\tt_modpost_translate_outlet tmp070 = compute_modpost_translate(tmp080.v_dist, tmp020);\n\tconst t_zero tmp014 = c_zero;\n\tt_modpost_translate_outlet tmp068 = compute_modpost_translate(tmp078.v_dist, tmp038);\n\tt_modpost_union_outlet tmp066 = compute_modpost_union(tmp074.v_dist, tmp076.v_dist);\n\tt_params tmp011 = u_params;\n\tt_sdf_box_outlet tmp095 = compute_sdf_box(tmp061.v_pos, tmp016);\n\tt_modpre_translate_outlet tmp057 = compute_modpre_translate(tmp053.v_pos1, vec3((tmp011.v_body_length * tmp006.v_stab_pos), tmp011.v_stab_v_height, c_zero.v_value));\n\tvec3 tmp010 = vec3(tmp011.v_stab_v_width, tmp011.v_stab_v_height, tmp006.v_stab_thickness);\n\tvec3 tmp015 = vec3(tmp013, tmp014.v_value, tmp014.v_value);\n\tconst t_zero tmp008 = c_zero;\n\tfloat tmp007 = (tmp011.v_body_length * tmp006.v_stab_pos);\n\tt_modpost_union_outlet tmp064 = compute_modpost_union(tmp070.v_dist, tmp072.v_dist);\n\tt_modpost_union_outlet tmp062 = compute_modpost_union(tmp066.v_dist, tmp068.v_dist);\n\tt_sdf_box_outlet tmp096 = compute_sdf_box(tmp057.v_pos, tmp010);\n\tvec3 tmp009 = vec3(tmp007, tmp011.v_stab_v_height, tmp008.v_value);\n\tt_modpost_union_outlet tmp058 = compute_modpost_union(tmp062.v_dist, tmp064.v_dist);\n\tt_modpost_translate_outlet tmp060 = compute_modpost_translate(tmp095.v_dist, tmp015);\n\tt_modpost_union_outlet tmp054 = compute_modpost_union(tmp058.v_dist, tmp060.v_dist);\n\tt_modpost_translate_outlet tmp056 = compute_modpost_translate(tmp096.v_dist, tmp009);\n\tconst t_zero tmp003 = c_zero;\n\tt_translation tmp005 = u_translation;\n\tt_modpost_union_outlet tmp052 = compute_modpost_union(tmp054.v_dist, tmp056.v_dist);\n\tvec3 tmp004 = vec3(tmp005.v_trans_X, tmp005.v_trans_Y, tmp005.v_trans_Z);\n\tt_modpost_rotate_outlet tmp050 = compute_modpost_rotate(tmp052.v_dist, tmp003.v_value, tmp005.v_rot_Y, tmp003.v_value);\n\tt_modpost_translate_outlet tmp048 = compute_modpost_translate(tmp050.v_dist, tmp004);\n\treturn t_outlet(tmp048.v_dist);\n}\n\nfloat eval_distance(vec3 pos) {\n\treturn compute_main_digraph(pos).v_dist;\n}\nvec3 eval_basecolor(vec3 pos) {\n\treturn vec3(-1.f);\n}\nfloat eval_roughness(vec3 pos) {\n\treturn -1.f;\n}\nfloat eval_metallic(vec3 pos) {\n\treturn -1.f;\n}\n", "car": "//// PREAMBLE\n\nfloat opp(float vv) { return -vv; }\n\nfloat vmin(vec2 vv) { return min(vv.x, vv.y); }\nfloat vmin(vec3 vv) { return min(min(vv.x, vv.y), vv.z); }\nfloat vmin(vec4 vv) { return min(min(vv.x, vv.y), min(vv.z, vv.w)); }\n\nfloat vmax(vec2 vv) { return max(vv.x, vv.y); }\nfloat vmax(vec3 vv) { return max(max(vv.x, vv.y), vv.z); }\nfloat vmax(vec4 vv) { return max(max(vv.x, vv.y), max(vv.z, vv.w)); }\n\n// According to the Kronos documentation, the fract of the input is computing\n// in this way 'x-floor(x)' which result to wrong results with negative values.\nfloat fractOfPositiveAndNegativeValue(float vv) {\n  return vv < 0.0 ? vv - ceil(vv) : vv - floor(vv);\n}\nvec2 fractOfPositiveAndNegativeValue(vec2 vv) {\n  return vec2(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y));\n}\nvec3 fractOfPositiveAndNegativeValue(vec3 vv) {\n  return vec3(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z));\n}\nvec4 fractOfPositiveAndNegativeValue(vec4 vv) {\n  return vec4(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z),\n    fractOfPositiveAndNegativeValue(vv.w));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n  float n = dot(i, step);\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec2 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec3 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n// https://www.pcg-random.org/\nfloat noisePcg(float q){\n  uint v = uint(round(q));\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float(float((word >> 22u) ^ word) * (1.0/float(0xffffffffu))) ;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh  \nvec2 noisePcg(vec2 q){\n  uvec2 v = uvec2(q);\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  return vec2(vec2(v)* (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec3 noisePcg(vec3 q){\n  uvec3 v = uvec3(q);\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  \n  return vec3(vec3(v) * (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec4 noisePcg(vec4 q){\n  uvec4 v = uvec4(q);\n  v = v * 1664525u + 1013904223u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  v ^= v >> 16u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  return vec4(vec4(v) * (1.0/float(0xffffffffu)));\n}\n\n\n//// CUSTOM TYPES\n\nstruct t_translation {\n\tvec3 v_offset;\n};\n\nstruct t_params {\n\tfloat v_length;\n\tfloat v_width;\n\tfloat v_height;\n\tfloat v_top_length;\n\tfloat v_top_width;\n\tfloat v_top_height;\n\tfloat v_top_smooth;\n\tfloat v_top_shift_length;\n\tfloat v_shell;\n\tfloat v_top_shell;\n\tfloat v_wheels_radius;\n\tfloat v_wheels_width;\n\tfloat v_wheels_pos_length;\n\tfloat v_wheels_pos_width;\n\tfloat v_wheels_pos_height;\n\tfloat v_wheels_shell;\n};\n\nstruct t_zero {\n\tfloat v_value;\n};\n\nstruct t_half_pi {\n\tfloat v_value;\n};\n\nstruct t_half {\n\tfloat v_value;\n};\n\nstruct t_one {\n\tfloat v_value;\n};\n\nstruct t_smooth_eps {\n\tfloat v_eps;\n};\n\nstruct t_modpre_rotate_inlet {\n\tvec3 v_pos;\n\tfloat v_angle_x;\n\tfloat v_angle_y;\n\tfloat v_angle_z;\n};\nstruct t_modpre_rotate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_union_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n};\nstruct t_modpost_union_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_cylinder_inlet {\n\tvec3 v_pos;\n\tfloat v_height;\n\tfloat v_radius;\n};\nstruct t_sdf_cylinder_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_box_inlet {\n\tvec3 v_pos;\n\tvec3 v_bounding_box;\n};\nstruct t_sdf_box_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_shell_inlet {\n\tvec3 v_pos;\n\tfloat v_thickness;\n};\nstruct t_modpre_shell_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_shell_inlet {\n\tfloat v_dist;\n\tfloat v_thickness;\n};\nstruct t_modpost_shell_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpost_rotate_inlet {\n\tfloat v_dist;\n\tfloat v_angle_x;\n\tfloat v_angle_y;\n\tfloat v_angle_z;\n};\nstruct t_modpost_rotate_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_translate_inlet {\n\tvec3 v_pos;\n\tvec3 v_offset;\n};\nstruct t_modpre_translate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_translate_inlet {\n\tfloat v_dist;\n\tvec3 v_offset;\n};\nstruct t_modpost_translate_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_mirror_x_inlet {\n\tvec3 v_pos;\n};\nstruct t_modpre_mirror_x_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_mirror_x_inlet {\n\tfloat v_dist;\n};\nstruct t_modpost_mirror_x_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_union_inlet {\n\tvec3 v_pos;\n};\nstruct t_modpre_union_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\nstruct t_modpre_mirror_z_inlet {\n\tvec3 v_pos;\n};\nstruct t_modpre_mirror_z_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_mirror_z_inlet {\n\tfloat v_dist;\n};\nstruct t_modpost_mirror_z_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_smooth_union_inlet {\n\tvec3 v_pos;\n\tfloat v_factor;\n};\nstruct t_modpre_smooth_union_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\nstruct t_modpost_smooth_union_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n\tfloat v_factor;\n};\nstruct t_modpost_smooth_union_outlet {\n\tfloat v_dist;\n};\n\nstruct t_position {\n\tvec3 v_pos;\n};\nstruct t_outlet {\n\tfloat v_dist;\n};\n\n//// PROTOTYPES\n\n// float operator+(float a_a, float a_b); // FUNCID(126) builtin arithmetic\n// vec3 operator-(vec3 a_a, vec3 a_b); // FUNCID(140) builtin arithmetic\n// float operator-(float a_a, float a_b); // FUNCID(138) builtin arithmetic\n// vec2 abs(vec2 a_i); // FUNCID(3) builtin operator\n// vec3 max(vec3 a_a, vec3 a_b); // FUNCID(67) builtin operator\n// float operator*(float a_a, float a_b); // FUNCID(131) builtin arithmetic\n// float abs(float a_i); // FUNCID(4) builtin operator\n// float opp(float a_i); // FUNCID(84) builtin operator\n// vec3 operator*(vec3 a_a, float a_b); // FUNCID(136) builtin arithmetic\n// float sin(float a_i); // FUNCID(98) builtin operator\n// float min(float a_a, float a_b); // FUNCID(69) builtin operator\n// vec3 operator*(mat3 a_a, vec3 a_b); // FUNCID(130) builtin arithmetic\n// float max(float a_a, float a_b); // FUNCID(66) builtin operator\n// float length(vec3 a_i); // FUNCID(59) builtin operator\n// vec2 operator-(vec2 a_a, vec2 a_b); // FUNCID(139) builtin arithmetic\n// vec3 abs(vec3 a_i); // FUNCID(11) builtin operator\n// float length(vec2 a_i); // FUNCID(58) builtin operator\n// vec2 max(vec2 a_a, vec2 a_b); // FUNCID(61) builtin operator\n// float vmax(vec2 a_i); // FUNCID(90) builtin operator\n// float cos(float a_i); // FUNCID(37) builtin operator\n// float operator/(float a_a, float a_b); // FUNCID(6) builtin arithmetic\nt_modpre_rotate_outlet compute_modpre_rotate(vec3 a_pos, float a_angle_x, float a_angle_y, float a_angle_z); // FUNCID(293) terminal\nt_modpost_union_outlet compute_modpost_union(float a_dist0, float a_dist1); // FUNCID(166) terminal\nt_sdf_cylinder_outlet compute_sdf_cylinder(vec3 a_pos, float a_height, float a_radius); // FUNCID(230) terminal\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box); // FUNCID(206) terminal\nt_modpre_shell_outlet compute_modpre_shell(vec3 a_pos, float a_thickness); // FUNCID(335) terminal\nt_modpost_shell_outlet compute_modpost_shell(float a_dist, float a_thickness); // FUNCID(338) terminal\nt_modpost_rotate_outlet compute_modpost_rotate(float a_dist, float a_angle_x, float a_angle_y, float a_angle_z); // FUNCID(296) terminal\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset); // FUNCID(286) terminal\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset); // FUNCID(289) terminal\nt_modpre_mirror_x_outlet compute_modpre_mirror_x(vec3 a_pos); // FUNCID(152) terminal\nt_modpost_mirror_x_outlet compute_modpost_mirror_x(float a_dist); // FUNCID(155) terminal\nt_modpre_union_outlet compute_modpre_union(vec3 a_pos); // FUNCID(163) terminal\nt_modpre_mirror_z_outlet compute_modpre_mirror_z(vec3 a_pos); // FUNCID(177) terminal\nt_modpost_mirror_z_outlet compute_modpost_mirror_z(float a_dist); // FUNCID(180) terminal\nt_modpre_smooth_union_outlet compute_modpre_smooth_union(vec3 a_pos, float a_factor); // FUNCID(199) terminal\nt_modpost_smooth_union_outlet compute_modpost_smooth_union(float a_dist0, float a_dist1, float a_factor); // FUNCID(202) terminal\nt_outlet compute_main_digraph(vec3 a_pos); // FUNCID(422) terminal\n\n//// INSTANCES\n\nuniform t_translation u_translation;\nuniform t_params u_params;\nconst t_zero c_zero = t_zero(float(0));\nconst t_half_pi c_half_pi = t_half_pi(float(1.5707964));\nconst t_half c_half = t_half(float(0.5));\nconst t_one c_one = t_one(float(1));\nconst t_smooth_eps c_smooth_eps = t_smooth_eps(float(0.0001));\n\n//// IMPLEMENTATIONS\n\n// FUNCID(152) 1i->1o ComposeFuncType::Terminal [modpre_mirror_x_inlet,modpre_mirror_x_outlet,compute_modpre_mirror_x]\n// ...\n// ...\nt_modpre_mirror_x_outlet compute_modpre_mirror_x(vec3 a_pos) {\n\tt_modpre_mirror_x_inlet tmp000 = t_modpre_mirror_x_inlet(a_pos);\n\tvec3 tmp002 = tmp000.v_pos;\n\tfloat tmp003 = opp(tmp002.x);\n\tvec3 tmp004 = vec3(tmp003, tmp002.y, tmp002.z);\n\treturn t_modpre_mirror_x_outlet(tmp004);\n}\n\n// FUNCID(155) 1i->1o ComposeFuncType::Terminal [modpost_mirror_x_inlet,modpost_mirror_x_outlet,compute_modpost_mirror_x]\n// ...\n// ...\nt_modpost_mirror_x_outlet compute_modpost_mirror_x(float a_dist) {\n\tconst t_one tmp002 = c_one;\n\tt_modpost_mirror_x_inlet tmp000 = t_modpost_mirror_x_inlet(a_dist);\n\tfloat tmp003 = (tmp000.v_dist * tmp002.v_value);\n\treturn t_modpost_mirror_x_outlet(tmp003);\n}\n\n// FUNCID(163) 1i->2o ComposeFuncType::Terminal [modpre_union_inlet,modpre_union_outlet,compute_modpre_union]\n// ...\n// ...\nt_modpre_union_outlet compute_modpre_union(vec3 a_pos) {\n\tt_modpre_union_inlet tmp003 = t_modpre_union_inlet(a_pos);\n\tconst t_one tmp001 = c_one;\n\tvec3 tmp000 = (tmp003.v_pos * tmp001.v_value);\n\treturn t_modpre_union_outlet(tmp000, tmp000);\n}\n\n// FUNCID(166) 2i->1o ComposeFuncType::Terminal [modpost_union_inlet,modpost_union_outlet,compute_modpost_union]\n// ...\n// ...\nt_modpost_union_outlet compute_modpost_union(float a_dist0, float a_dist1) {\n\tt_modpost_union_inlet tmp002 = t_modpost_union_inlet(a_dist0, a_dist1);\n\tfloat tmp000 = min(tmp002.v_dist0, tmp002.v_dist1);\n\treturn t_modpost_union_outlet(tmp000);\n}\n\n// FUNCID(177) 1i->1o ComposeFuncType::Terminal [modpre_mirror_z_inlet,modpre_mirror_z_outlet,compute_modpre_mirror_z]\n// ...\n// ...\nt_modpre_mirror_z_outlet compute_modpre_mirror_z(vec3 a_pos) {\n\tt_modpre_mirror_z_inlet tmp000 = t_modpre_mirror_z_inlet(a_pos);\n\tvec3 tmp002 = tmp000.v_pos;\n\tfloat tmp003 = opp(tmp002.z);\n\tvec3 tmp004 = vec3(tmp002.x, tmp002.y, tmp003);\n\treturn t_modpre_mirror_z_outlet(tmp004);\n}\n\n// FUNCID(180) 1i->1o ComposeFuncType::Terminal [modpost_mirror_z_inlet,modpost_mirror_z_outlet,compute_modpost_mirror_z]\n// ...\n// ...\nt_modpost_mirror_z_outlet compute_modpost_mirror_z(float a_dist) {\n\tconst t_one tmp002 = c_one;\n\tt_modpost_mirror_z_inlet tmp000 = t_modpost_mirror_z_inlet(a_dist);\n\tfloat tmp003 = (tmp000.v_dist * tmp002.v_value);\n\treturn t_modpost_mirror_z_outlet(tmp003);\n}\n\n// FUNCID(199) 2i->2o ComposeFuncType::Terminal [modpre_smooth_union_inlet,modpre_smooth_union_outlet,compute_modpre_smooth_union]\n// ...\n// ...\nt_modpre_smooth_union_outlet compute_modpre_smooth_union(vec3 a_pos, float a_factor) {\n\tconst t_one tmp002 = c_one;\n\tt_modpre_smooth_union_inlet tmp000 = t_modpre_smooth_union_inlet(a_pos, a_factor);\n\tvec3 tmp003 = (tmp000.v_pos * tmp002.v_value);\n\treturn t_modpre_smooth_union_outlet(tmp003, tmp003);\n}\n\n// FUNCID(202) 3i->1o ComposeFuncType::Terminal [modpost_smooth_union_inlet,modpost_smooth_union_outlet,compute_modpost_smooth_union]\n// ...\n// ...\nt_modpost_smooth_union_outlet compute_modpost_smooth_union(float a_dist0, float a_dist1, float a_factor) {\n\tfloat tmp002 = (t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor).v_dist0 - t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor).v_dist1);\n\tfloat tmp014 = abs(tmp002);\n\tconst t_zero tmp005 = c_zero;\n\tfloat tmp003 = (max(t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor).v_factor, c_smooth_eps.v_eps) - tmp014);\n\tfloat tmp004 = max(tmp003, tmp005.v_value);\n\tfloat tmp006 = (tmp004 / max(t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor).v_factor, c_smooth_eps.v_eps));\n\tconst t_smooth_eps tmp016 = c_smooth_eps;\n\tfloat tmp015 = max(t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor).v_factor, tmp016.v_eps);\n\tconst t_half tmp010 = c_half;\n\tfloat tmp008 = (tmp006 * tmp006);\n\tt_modpost_smooth_union_inlet tmp000 = t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor);\n\tfloat tmp011 = (tmp010.v_value * tmp010.v_value);\n\tfloat tmp009 = (tmp008 * tmp015);\n\tfloat tmp012 = (tmp009 * tmp011);\n\tfloat tmp007 = min(tmp000.v_dist0, tmp000.v_dist1);\n\tfloat tmp013 = (tmp007 - tmp012);\n\treturn t_modpost_smooth_union_outlet(tmp013);\n}\n\n// FUNCID(206) 2i->1o ComposeFuncType::Terminal [sdf_box_inlet,sdf_box_outlet,compute_sdf_box]\n// ...\n// ...\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box) {\n\tconst t_zero tmp006 = c_zero;\n\tt_sdf_box_inlet tmp000 = t_sdf_box_inlet(a_pos, a_bounding_box);\n\tvec3 tmp002 = abs(tmp000.v_pos);\n\tvec3 tmp004 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp003 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp008 = vec3(tmp006.v_value, tmp006.v_value, tmp006.v_value);\n\tfloat tmp005 = max(tmp004.y, tmp004.z);\n\tconst t_zero tmp012 = c_zero;\n\tfloat tmp010 = max(tmp004.x, tmp005);\n\tvec3 tmp007 = max(tmp008, tmp003);\n\tfloat tmp011 = min(tmp012.v_value, tmp010);\n\tfloat tmp009 = length(tmp007);\n\tfloat tmp013 = (tmp009 + tmp011);\n\treturn t_sdf_box_outlet(tmp013);\n}\n\n// FUNCID(230) 3i->1o ComposeFuncType::Terminal [sdf_cylinder_inlet,sdf_cylinder_outlet,compute_sdf_cylinder]\n// ...\n// ...\nt_sdf_cylinder_outlet compute_sdf_cylinder(vec3 a_pos, float a_height, float a_radius) {\n\tvec2 tmp003 = vec2(t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos.z);\n\tvec3 tmp002 = t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos;\n\tfloat tmp004 = length(tmp003);\n\tt_sdf_cylinder_inlet tmp000 = t_sdf_cylinder_inlet(a_pos, a_height, a_radius);\n\tvec2 tmp006 = vec2(tmp004, tmp002.y);\n\tvec2 tmp007 = abs(tmp006);\n\tvec2 tmp005 = vec2(tmp000.v_radius, tmp000.v_height);\n\tvec2 tmp008 = (tmp007 - tmp005);\n\tvec2 tmp013 = vec2(c_zero.v_value, c_zero.v_value);\n\tconst t_zero tmp010 = c_zero;\n\tvec2 tmp012 = max(tmp008, tmp013);\n\tfloat tmp009 = vmax(tmp008);\n\tfloat tmp015 = length(tmp012);\n\tfloat tmp011 = min(tmp009, tmp010.v_value);\n\tfloat tmp014 = (tmp011 + tmp015);\n\treturn t_sdf_cylinder_outlet(tmp014);\n}\n\n// FUNCID(286) 2i->1o ComposeFuncType::Terminal [modpre_translate_inlet,modpre_translate_outlet,compute_modpre_translate]\n// ...\n// ...\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset) {\n\tt_modpre_translate_inlet tmp000 = t_modpre_translate_inlet(a_pos, a_offset);\n\tvec3 tmp002 = (tmp000.v_pos - tmp000.v_offset);\n\treturn t_modpre_translate_outlet(tmp002);\n}\n\n// FUNCID(289) 2i->1o ComposeFuncType::Terminal [modpost_translate_inlet,modpost_translate_outlet,compute_modpost_translate]\n// ...\n// ...\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_translate_inlet tmp000 = t_modpost_translate_inlet(a_dist, a_offset);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_translate_outlet(tmp002);\n}\n\n// FUNCID(293) 4i->1o ComposeFuncType::Terminal [modpre_rotate_inlet,modpre_rotate_outlet,compute_modpre_rotate]\n// ...\n// ...\nt_modpre_rotate_outlet compute_modpre_rotate(vec3 a_pos, float a_angle_x, float a_angle_y, float a_angle_z) {\n\tfloat tmp024 = (sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp020 = (sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp015 = (cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp011 = (cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp009 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_x);\n\tfloat tmp008 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_x);\n\tfloat tmp007 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y);\n\tfloat tmp005 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z);\n\tfloat tmp004 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z);\n\tfloat tmp006 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y);\n\tfloat tmp027 = (tmp005 * tmp009);\n\tfloat tmp025 = (tmp024 * tmp008);\n\tfloat tmp023 = (tmp005 * tmp008);\n\tfloat tmp021 = (tmp020 * tmp009);\n\tfloat tmp018 = (tmp004 * tmp009);\n\tfloat tmp016 = (tmp015 * tmp008);\n\tfloat tmp014 = (tmp004 * tmp008);\n\tfloat tmp012 = (tmp011 * tmp009);\n\tfloat tmp030 = (tmp006 * tmp008);\n\tfloat tmp029 = (tmp006 * tmp009);\n\tfloat tmp028 = opp(tmp007);\n\tfloat tmp026 = (tmp025 - tmp027);\n\tfloat tmp022 = (tmp021 + tmp023);\n\tfloat tmp019 = (tmp004 * tmp006);\n\tfloat tmp017 = (tmp016 + tmp018);\n\tfloat tmp013 = (tmp012 - tmp014);\n\tfloat tmp010 = (tmp005 * tmp006);\n\tt_modpre_rotate_inlet tmp000 = t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z);\n\tmat3 tmp002 = mat3(tmp010, tmp013, tmp017, tmp019, tmp022, tmp026, tmp028, tmp029, tmp030);\n\tvec3 tmp003 = (tmp002 * tmp000.v_pos);\n\treturn t_modpre_rotate_outlet(tmp003);\n}\n\n// FUNCID(296) 4i->1o ComposeFuncType::Terminal [modpost_rotate_inlet,modpost_rotate_outlet,compute_modpost_rotate]\n// ...\n// ...\nt_modpost_rotate_outlet compute_modpost_rotate(float a_dist, float a_angle_x, float a_angle_y, float a_angle_z) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_rotate_inlet tmp000 = t_modpost_rotate_inlet(a_dist, a_angle_x, a_angle_y, a_angle_z);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_rotate_outlet(tmp002);\n}\n\n// FUNCID(335) 2i->1o ComposeFuncType::Terminal [modpre_shell_inlet,modpre_shell_outlet,compute_modpre_shell]\n// ...\n// ...\nt_modpre_shell_outlet compute_modpre_shell(vec3 a_pos, float a_thickness) {\n\tconst t_one tmp003 = c_one;\n\tt_modpre_shell_inlet tmp000 = t_modpre_shell_inlet(a_pos, a_thickness);\n\tvec3 tmp002 = (tmp000.v_pos * tmp003.v_value);\n\treturn t_modpre_shell_outlet(tmp002);\n}\n\n// FUNCID(338) 2i->1o ComposeFuncType::Terminal [modpost_shell_inlet,modpost_shell_outlet,compute_modpost_shell]\n// ...\n// ...\nt_modpost_shell_outlet compute_modpost_shell(float a_dist, float a_thickness) {\n\tt_modpost_shell_inlet tmp000 = t_modpost_shell_inlet(a_dist, a_thickness);\n\tfloat tmp002 = abs(tmp000.v_dist);\n\tfloat tmp003 = (tmp002 - tmp000.v_thickness);\n\treturn t_modpost_shell_outlet(tmp003);\n}\n\n// FUNCID(422) 1i->1o ComposeFuncType::Terminal [position,outlet,compute_main_digraph]\n// ...\n// ...\nt_outlet compute_main_digraph(vec3 a_pos) {\n\tt_modpre_mirror_z_outlet tmp037 = compute_modpre_mirror_z(compute_modpre_union(compute_modpre_union(compute_modpre_translate(t_position(a_pos).v_pos, u_translation.v_offset).v_pos).v_pos1).v_pos0);\n\tt_modpre_mirror_x_outlet tmp053 = compute_modpre_mirror_x(compute_modpre_union(tmp037.v_pos).v_pos0);\n\tt_modpre_union_outlet tmp029 = compute_modpre_union(compute_modpre_union(compute_modpre_translate(t_position(a_pos).v_pos, u_translation.v_offset).v_pos).v_pos1);\n\tt_modpre_union_outlet tmp045 = compute_modpre_union(tmp037.v_pos);\n\tt_modpre_mirror_x_outlet tmp043 = compute_modpre_mirror_x(compute_modpre_union(tmp029.v_pos1).v_pos0);\n\tt_modpre_translate_outlet tmp061 = compute_modpre_translate(tmp053.v_pos, vec3((u_params.v_width * u_params.v_wheels_pos_width), (u_params.v_height * u_params.v_wheels_pos_height), (u_params.v_length * u_params.v_wheels_pos_length)));\n\tt_modpre_translate_outlet tmp051 = compute_modpre_translate(tmp045.v_pos1, vec3((u_params.v_width * u_params.v_wheels_pos_width), (u_params.v_height * u_params.v_wheels_pos_height), (u_params.v_length * u_params.v_wheels_pos_length)));\n\tt_modpre_translate_outlet tmp049 = compute_modpre_translate(tmp043.v_pos, vec3((u_params.v_width * u_params.v_wheels_pos_width), (u_params.v_height * u_params.v_wheels_pos_height), (u_params.v_length * u_params.v_wheels_pos_length)));\n\tt_modpre_union_outlet tmp035 = compute_modpre_union(tmp029.v_pos1);\n\tt_modpre_rotate_outlet tmp067 = compute_modpre_rotate(tmp061.v_pos, c_half_pi.v_value, c_half_pi.v_value, c_zero.v_value);\n\tt_modpre_rotate_outlet tmp059 = compute_modpre_rotate(tmp051.v_pos, c_half_pi.v_value, c_half_pi.v_value, c_zero.v_value);\n\tt_modpre_shell_outlet tmp069 = compute_modpre_shell(tmp067.v_pos, u_params.v_wheels_shell);\n\tt_modpre_translate_outlet tmp041 = compute_modpre_translate(tmp035.v_pos1, vec3((u_params.v_width * u_params.v_wheels_pos_width), (u_params.v_height * u_params.v_wheels_pos_height), (u_params.v_length * u_params.v_wheels_pos_length)));\n\tt_modpre_rotate_outlet tmp057 = compute_modpre_rotate(tmp049.v_pos, c_half_pi.v_value, c_half_pi.v_value, c_zero.v_value);\n\tt_modpre_rotate_outlet tmp047 = compute_modpre_rotate(tmp041.v_pos, c_half_pi.v_value, c_half_pi.v_value, c_zero.v_value);\n\tt_sdf_cylinder_outlet tmp070 = compute_sdf_cylinder(tmp069.v_pos, u_params.v_wheels_width, (u_params.v_wheels_radius - u_params.v_wheels_shell));\n\tt_modpre_shell_outlet tmp063 = compute_modpre_shell(tmp057.v_pos, u_params.v_wheels_shell);\n\tt_position tmp021 = t_position(a_pos);\n\tt_modpre_shell_outlet tmp065 = compute_modpre_shell(tmp059.v_pos, u_params.v_wheels_shell);\n\tt_modpost_shell_outlet tmp068 = compute_modpost_shell(tmp070.v_dist, u_params.v_wheels_shell);\n\tfloat tmp007 = (u_params.v_wheels_radius - u_params.v_wheels_shell);\n\tt_sdf_cylinder_outlet tmp071 = compute_sdf_cylinder(tmp065.v_pos, u_params.v_wheels_width, tmp007);\n\tt_sdf_cylinder_outlet tmp072 = compute_sdf_cylinder(tmp063.v_pos, u_params.v_wheels_width, tmp007);\n\tt_modpre_translate_outlet tmp023 = compute_modpre_translate(tmp021.v_pos, u_translation.v_offset);\n\tt_modpre_shell_outlet tmp055 = compute_modpre_shell(tmp047.v_pos, u_params.v_wheels_shell);\n\tt_params tmp008 = u_params;\n\tt_sdf_cylinder_outlet tmp073 = compute_sdf_cylinder(tmp055.v_pos, tmp008.v_wheels_width, tmp007);\n\tvec3 tmp016 = vec3(u_params.v_top_width, u_params.v_top_height, u_params.v_top_length);\n\tt_modpost_rotate_outlet tmp066 = compute_modpost_rotate(tmp068.v_dist, c_half_pi.v_value, c_half_pi.v_value, c_zero.v_value);\n\tt_modpre_union_outlet tmp025 = compute_modpre_union(tmp023.v_pos);\n\tvec3 tmp009 = vec3(u_params.v_top_shell, u_params.v_top_shell, u_params.v_top_shell);\n\tt_modpre_translate_outlet tmp031 = compute_modpre_translate(compute_modpre_smooth_union(tmp025.v_pos0, u_params.v_top_smooth).v_pos1, vec3(c_zero.v_value, (u_params.v_height + u_params.v_top_height), (u_params.v_length * u_params.v_top_shift_length)));\n\tt_modpost_shell_outlet tmp064 = compute_modpost_shell(tmp071.v_dist, tmp008.v_wheels_shell);\n\tt_modpost_shell_outlet tmp062 = compute_modpost_shell(tmp072.v_dist, tmp008.v_wheels_shell);\n\tconst t_half_pi tmp003 = c_half_pi;\n\tvec3 tmp017 = vec3(u_params.v_width, u_params.v_height, u_params.v_length);\n\tconst t_zero tmp004 = c_zero;\n\tt_modpost_shell_outlet tmp054 = compute_modpost_shell(tmp073.v_dist, tmp008.v_wheels_shell);\n\tt_modpre_smooth_union_outlet tmp027 = compute_modpre_smooth_union(tmp025.v_pos0, u_params.v_top_smooth);\n\tt_modpost_translate_outlet tmp060 = compute_modpost_translate(tmp066.v_dist, vec3((tmp008.v_width * tmp008.v_wheels_pos_width), (tmp008.v_height * tmp008.v_wheels_pos_height), (tmp008.v_length * tmp008.v_wheels_pos_length)));\n\tvec3 tmp010 = (tmp016 - tmp009);\n\tt_modpost_rotate_outlet tmp058 = compute_modpost_rotate(tmp064.v_dist, tmp003.v_value, tmp003.v_value, tmp004.v_value);\n\tvec3 tmp011 = vec3(u_params.v_shell, u_params.v_shell, u_params.v_shell);\n\tfloat tmp001 = (tmp008.v_height * tmp008.v_wheels_pos_height);\n\tt_modpre_shell_outlet tmp039 = compute_modpre_shell(tmp031.v_pos, u_params.v_top_shell);\n\tfloat tmp002 = (tmp008.v_width * tmp008.v_wheels_pos_width);\n\tt_modpost_rotate_outlet tmp056 = compute_modpost_rotate(tmp062.v_dist, tmp003.v_value, tmp003.v_value, tmp004.v_value);\n\tfloat tmp005 = (tmp008.v_length * tmp008.v_wheels_pos_length);\n\tvec3 tmp006 = vec3(tmp002, tmp001, tmp005);\n\tvec3 tmp012 = (tmp017 - tmp011);\n\tt_modpost_translate_outlet tmp050 = compute_modpost_translate(tmp058.v_dist, tmp006);\n\tt_modpost_mirror_x_outlet tmp052 = compute_modpost_mirror_x(tmp060.v_dist);\n\tt_modpre_shell_outlet tmp033 = compute_modpre_shell(tmp027.v_pos0, u_params.v_shell);\n\tt_sdf_box_outlet tmp074 = compute_sdf_box(tmp039.v_pos, tmp010);\n\tfloat tmp000 = (u_params.v_length * u_params.v_top_shift_length);\n\tt_modpost_rotate_outlet tmp046 = compute_modpost_rotate(tmp054.v_dist, tmp003.v_value, tmp003.v_value, tmp004.v_value);\n\tt_modpost_translate_outlet tmp048 = compute_modpost_translate(tmp056.v_dist, tmp006);\n\tconst t_zero tmp014 = c_zero;\n\tfloat tmp013 = (u_params.v_height + u_params.v_top_height);\n\tvec3 tmp015 = vec3(tmp014.v_value, tmp013, tmp000);\n\tt_modpost_union_outlet tmp044 = compute_modpost_union(tmp052.v_dist, tmp050.v_dist);\n\tt_modpost_translate_outlet tmp040 = compute_modpost_translate(tmp046.v_dist, tmp006);\n\tt_sdf_box_outlet tmp075 = compute_sdf_box(tmp033.v_pos, tmp012);\n\tt_modpost_shell_outlet tmp038 = compute_modpost_shell(tmp074.v_dist, u_params.v_top_shell);\n\tt_modpost_mirror_x_outlet tmp042 = compute_modpost_mirror_x(tmp048.v_dist);\n\tt_params tmp018 = u_params;\n\tt_modpost_mirror_z_outlet tmp036 = compute_modpost_mirror_z(tmp044.v_dist);\n\tt_modpost_union_outlet tmp034 = compute_modpost_union(tmp042.v_dist, tmp040.v_dist);\n\tt_modpost_translate_outlet tmp030 = compute_modpost_translate(tmp038.v_dist, tmp015);\n\tt_modpost_shell_outlet tmp032 = compute_modpost_shell(tmp075.v_dist, tmp018.v_shell);\n\tt_modpost_smooth_union_outlet tmp026 = compute_modpost_smooth_union(tmp032.v_dist, tmp030.v_dist, tmp018.v_top_smooth);\n\tt_modpost_union_outlet tmp028 = compute_modpost_union(tmp036.v_dist, tmp034.v_dist);\n\tt_translation tmp019 = u_translation;\n\tt_modpost_union_outlet tmp024 = compute_modpost_union(tmp026.v_dist, tmp028.v_dist);\n\tt_modpost_translate_outlet tmp022 = compute_modpost_translate(tmp024.v_dist, tmp019.v_offset);\n\treturn t_outlet(tmp022.v_dist);\n}\n\nfloat eval_distance(vec3 pos) {\n\treturn compute_main_digraph(pos).v_dist;\n}\nvec3 eval_basecolor(vec3 pos) {\n\treturn vec3(-1.f);\n}\nfloat eval_roughness(vec3 pos) {\n\treturn -1.f;\n}\nfloat eval_metallic(vec3 pos) {\n\treturn -1.f;\n}\n", "box_simple": "//// PREAMBLE\n\nfloat opp(float vv) { return -vv; }\n\nfloat vmin(vec2 vv) { return min(vv.x, vv.y); }\nfloat vmin(vec3 vv) { return min(min(vv.x, vv.y), vv.z); }\nfloat vmin(vec4 vv) { return min(min(vv.x, vv.y), min(vv.z, vv.w)); }\n\nfloat vmax(vec2 vv) { return max(vv.x, vv.y); }\nfloat vmax(vec3 vv) { return max(max(vv.x, vv.y), vv.z); }\nfloat vmax(vec4 vv) { return max(max(vv.x, vv.y), max(vv.z, vv.w)); }\n\n// According to the Kronos documentation, the fract of the input is computing\n// in this way 'x-floor(x)' which result to wrong results with negative values.\nfloat fractOfPositiveAndNegativeValue(float vv) {\n  return vv < 0.0 ? vv - ceil(vv) : vv - floor(vv);\n}\nvec2 fractOfPositiveAndNegativeValue(vec2 vv) {\n  return vec2(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y));\n}\nvec3 fractOfPositiveAndNegativeValue(vec3 vv) {\n  return vec3(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z));\n}\nvec4 fractOfPositiveAndNegativeValue(vec4 vv) {\n  return vec4(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z),\n    fractOfPositiveAndNegativeValue(vv.w));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n  float n = dot(i, step);\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec2 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec3 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n// https://www.pcg-random.org/\nfloat noisePcg(float q){\n  uint v = uint(round(q));\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float(float((word >> 22u) ^ word) * (1.0/float(0xffffffffu))) ;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh  \nvec2 noisePcg(vec2 q){\n  uvec2 v = uvec2(q);\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  return vec2(vec2(v)* (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec3 noisePcg(vec3 q){\n  uvec3 v = uvec3(q);\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  \n  return vec3(vec3(v) * (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec4 noisePcg(vec4 q){\n  uvec4 v = uvec4(q);\n  v = v * 1664525u + 1013904223u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  v ^= v >> 16u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  return vec4(vec4(v) * (1.0/float(0xffffffffu)));\n}\n\n\n//// CUSTOM TYPES\n\nstruct t_zero {\n\tfloat v_value;\n};\n\nstruct t_box_width {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_box_position {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_sdf_box_inlet {\n\tvec3 v_pos;\n\tvec3 v_bounding_box;\n};\nstruct t_sdf_box_outlet {\n\tfloat v_dist;\n};\n\nstruct t_position {\n\tvec3 v_pos;\n};\nstruct t_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_translate_inlet {\n\tvec3 v_pos;\n\tvec3 v_offset;\n};\nstruct t_modpre_translate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_translate_inlet {\n\tfloat v_dist;\n\tvec3 v_offset;\n};\nstruct t_modpost_translate_outlet {\n\tfloat v_dist;\n};\n\n//// PROTOTYPES\n\n// float operator+(float a_a, float a_b); // FUNCID(126) builtin arithmetic\n// vec3 operator-(vec3 a_a, vec3 a_b); // FUNCID(140) builtin arithmetic\n// float min(float a_a, float a_b); // FUNCID(69) builtin operator\n// float max(float a_a, float a_b); // FUNCID(66) builtin operator\n// float length(vec3 a_i); // FUNCID(59) builtin operator\n// vec3 max(vec3 a_a, vec3 a_b); // FUNCID(67) builtin operator\n// vec3 abs(vec3 a_i); // FUNCID(11) builtin operator\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box); // FUNCID(206) terminal\nt_outlet compute_main_digraph(vec3 a_pos); // FUNCID(422) terminal\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset); // FUNCID(286) terminal\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset); // FUNCID(289) terminal\n\n//// INSTANCES\n\nconst t_zero c_zero = t_zero(float(0));\nuniform t_box_width u_box_width;\nuniform t_box_position u_box_position;\n\n//// IMPLEMENTATIONS\n\n// FUNCID(206) 2i->1o ComposeFuncType::Terminal [sdf_box_inlet,sdf_box_outlet,compute_sdf_box]\n// ...\n// ...\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box) {\n\tconst t_zero tmp006 = c_zero;\n\tt_sdf_box_inlet tmp000 = t_sdf_box_inlet(a_pos, a_bounding_box);\n\tvec3 tmp002 = abs(tmp000.v_pos);\n\tvec3 tmp004 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp003 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp008 = vec3(tmp006.v_value, tmp006.v_value, tmp006.v_value);\n\tfloat tmp005 = max(tmp004.y, tmp004.z);\n\tconst t_zero tmp012 = c_zero;\n\tfloat tmp010 = max(tmp004.x, tmp005);\n\tvec3 tmp007 = max(tmp008, tmp003);\n\tfloat tmp011 = min(tmp012.v_value, tmp010);\n\tfloat tmp009 = length(tmp007);\n\tfloat tmp013 = (tmp009 + tmp011);\n\treturn t_sdf_box_outlet(tmp013);\n}\n\n// FUNCID(286) 2i->1o ComposeFuncType::Terminal [modpre_translate_inlet,modpre_translate_outlet,compute_modpre_translate]\n// ...\n// ...\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset) {\n\tt_modpre_translate_inlet tmp000 = t_modpre_translate_inlet(a_pos, a_offset);\n\tvec3 tmp002 = (tmp000.v_pos - tmp000.v_offset);\n\treturn t_modpre_translate_outlet(tmp002);\n}\n\n// FUNCID(289) 2i->1o ComposeFuncType::Terminal [modpost_translate_inlet,modpost_translate_outlet,compute_modpost_translate]\n// ...\n// ...\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_translate_inlet tmp000 = t_modpost_translate_inlet(a_dist, a_offset);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_translate_outlet(tmp002);\n}\n\n// FUNCID(422) 1i->1o ComposeFuncType::Terminal [position,outlet,compute_main_digraph]\n// ...\n// ...\nt_outlet compute_main_digraph(vec3 a_pos) {\n\tt_box_width tmp004 = u_box_width;\n\tt_position tmp006 = t_position(a_pos);\n\tt_box_position tmp003 = u_box_position;\n\tt_modpre_translate_outlet tmp008 = compute_modpre_translate(tmp006.v_pos, vec3(tmp003.v_X, (tmp004.v_Y + tmp003.v_Y), tmp003.v_Z));\n\tvec3 tmp001 = vec3(tmp004.v_X, tmp004.v_Y, tmp004.v_Z);\n\tfloat tmp000 = (tmp004.v_Y + tmp003.v_Y);\n\tvec3 tmp002 = vec3(tmp003.v_X, tmp000, tmp003.v_Z);\n\tt_sdf_box_outlet tmp009 = compute_sdf_box(tmp008.v_pos, tmp001);\n\tt_modpost_translate_outlet tmp007 = compute_modpost_translate(tmp009.v_dist, tmp002);\n\treturn t_outlet(tmp007.v_dist);\n}\n\nfloat eval_distance(vec3 pos) {\n\treturn compute_main_digraph(pos).v_dist;\n}\nvec3 eval_basecolor(vec3 pos) {\n\treturn vec3(-1.f);\n}\nfloat eval_roughness(vec3 pos) {\n\treturn -1.f;\n}\nfloat eval_metallic(vec3 pos) {\n\treturn -1.f;\n}\n", "box_double": "//// PREAMBLE\n\nfloat opp(float vv) { return -vv; }\n\nfloat vmin(vec2 vv) { return min(vv.x, vv.y); }\nfloat vmin(vec3 vv) { return min(min(vv.x, vv.y), vv.z); }\nfloat vmin(vec4 vv) { return min(min(vv.x, vv.y), min(vv.z, vv.w)); }\n\nfloat vmax(vec2 vv) { return max(vv.x, vv.y); }\nfloat vmax(vec3 vv) { return max(max(vv.x, vv.y), vv.z); }\nfloat vmax(vec4 vv) { return max(max(vv.x, vv.y), max(vv.z, vv.w)); }\n\n// According to the Kronos documentation, the fract of the input is computing\n// in this way 'x-floor(x)' which result to wrong results with negative values.\nfloat fractOfPositiveAndNegativeValue(float vv) {\n  return vv < 0.0 ? vv - ceil(vv) : vv - floor(vv);\n}\nvec2 fractOfPositiveAndNegativeValue(vec2 vv) {\n  return vec2(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y));\n}\nvec3 fractOfPositiveAndNegativeValue(vec3 vv) {\n  return vec3(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z));\n}\nvec4 fractOfPositiveAndNegativeValue(vec4 vv) {\n  return vec4(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z),\n    fractOfPositiveAndNegativeValue(vv.w));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n  float n = dot(i, step);\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec2 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec3 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n// https://www.pcg-random.org/\nfloat noisePcg(float q){\n  uint v = uint(round(q));\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float(float((word >> 22u) ^ word) * (1.0/float(0xffffffffu))) ;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh  \nvec2 noisePcg(vec2 q){\n  uvec2 v = uvec2(q);\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  return vec2(vec2(v)* (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec3 noisePcg(vec3 q){\n  uvec3 v = uvec3(q);\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  \n  return vec3(vec3(v) * (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec4 noisePcg(vec4 q){\n  uvec4 v = uvec4(q);\n  v = v * 1664525u + 1013904223u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  v ^= v >> 16u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  return vec4(vec4(v) * (1.0/float(0xffffffffu)));\n}\n\n\n//// CUSTOM TYPES\n\nstruct t_box_width_top {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_box_position_top {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_box_width {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_box_position {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_zero {\n\tfloat v_value;\n};\n\nstruct t_one {\n\tfloat v_value;\n};\n\nstruct t_modpost_union_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n};\nstruct t_modpost_union_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_box_inlet {\n\tvec3 v_pos;\n\tvec3 v_bounding_box;\n};\nstruct t_sdf_box_outlet {\n\tfloat v_dist;\n};\n\nstruct t_position {\n\tvec3 v_pos;\n};\nstruct t_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_translate_inlet {\n\tvec3 v_pos;\n\tvec3 v_offset;\n};\nstruct t_modpre_translate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_translate_inlet {\n\tfloat v_dist;\n\tvec3 v_offset;\n};\nstruct t_modpost_translate_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_union_inlet {\n\tvec3 v_pos;\n};\nstruct t_modpre_union_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\n//// PROTOTYPES\n\n// float operator+(float a_a, float a_b); // FUNCID(126) builtin arithmetic\n// vec3 operator-(vec3 a_a, vec3 a_b); // FUNCID(140) builtin arithmetic\n// float min(float a_a, float a_b); // FUNCID(69) builtin operator\n// float max(float a_a, float a_b); // FUNCID(66) builtin operator\n// float length(vec3 a_i); // FUNCID(59) builtin operator\n// vec3 max(vec3 a_a, vec3 a_b); // FUNCID(67) builtin operator\n// vec3 abs(vec3 a_i); // FUNCID(11) builtin operator\n// vec3 operator*(vec3 a_a, float a_b); // FUNCID(136) builtin arithmetic\nt_modpost_union_outlet compute_modpost_union(float a_dist0, float a_dist1); // FUNCID(166) terminal\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box); // FUNCID(206) terminal\nt_outlet compute_main_digraph(vec3 a_pos); // FUNCID(422) terminal\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset); // FUNCID(286) terminal\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset); // FUNCID(289) terminal\nt_modpre_union_outlet compute_modpre_union(vec3 a_pos); // FUNCID(163) terminal\n\n//// INSTANCES\n\nuniform t_box_width_top u_box_width_top;\nuniform t_box_position_top u_box_position_top;\nuniform t_box_width u_box_width;\nuniform t_box_position u_box_position;\nconst t_zero c_zero = t_zero(float(0));\nconst t_one c_one = t_one(float(1));\n\n//// IMPLEMENTATIONS\n\n// FUNCID(163) 1i->2o ComposeFuncType::Terminal [modpre_union_inlet,modpre_union_outlet,compute_modpre_union]\n// ...\n// ...\nt_modpre_union_outlet compute_modpre_union(vec3 a_pos) {\n\tt_modpre_union_inlet tmp003 = t_modpre_union_inlet(a_pos);\n\tconst t_one tmp001 = c_one;\n\tvec3 tmp000 = (tmp003.v_pos * tmp001.v_value);\n\treturn t_modpre_union_outlet(tmp000, tmp000);\n}\n\n// FUNCID(166) 2i->1o ComposeFuncType::Terminal [modpost_union_inlet,modpost_union_outlet,compute_modpost_union]\n// ...\n// ...\nt_modpost_union_outlet compute_modpost_union(float a_dist0, float a_dist1) {\n\tt_modpost_union_inlet tmp002 = t_modpost_union_inlet(a_dist0, a_dist1);\n\tfloat tmp000 = min(tmp002.v_dist0, tmp002.v_dist1);\n\treturn t_modpost_union_outlet(tmp000);\n}\n\n// FUNCID(206) 2i->1o ComposeFuncType::Terminal [sdf_box_inlet,sdf_box_outlet,compute_sdf_box]\n// ...\n// ...\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box) {\n\tconst t_zero tmp006 = c_zero;\n\tt_sdf_box_inlet tmp000 = t_sdf_box_inlet(a_pos, a_bounding_box);\n\tvec3 tmp002 = abs(tmp000.v_pos);\n\tvec3 tmp004 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp003 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp008 = vec3(tmp006.v_value, tmp006.v_value, tmp006.v_value);\n\tfloat tmp005 = max(tmp004.y, tmp004.z);\n\tconst t_zero tmp012 = c_zero;\n\tfloat tmp010 = max(tmp004.x, tmp005);\n\tvec3 tmp007 = max(tmp008, tmp003);\n\tfloat tmp011 = min(tmp012.v_value, tmp010);\n\tfloat tmp009 = length(tmp007);\n\tfloat tmp013 = (tmp009 + tmp011);\n\treturn t_sdf_box_outlet(tmp013);\n}\n\n// FUNCID(286) 2i->1o ComposeFuncType::Terminal [modpre_translate_inlet,modpre_translate_outlet,compute_modpre_translate]\n// ...\n// ...\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset) {\n\tt_modpre_translate_inlet tmp000 = t_modpre_translate_inlet(a_pos, a_offset);\n\tvec3 tmp002 = (tmp000.v_pos - tmp000.v_offset);\n\treturn t_modpre_translate_outlet(tmp002);\n}\n\n// FUNCID(289) 2i->1o ComposeFuncType::Terminal [modpost_translate_inlet,modpost_translate_outlet,compute_modpost_translate]\n// ...\n// ...\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_translate_inlet tmp000 = t_modpost_translate_inlet(a_dist, a_offset);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_translate_outlet(tmp002);\n}\n\n// FUNCID(422) 1i->1o ComposeFuncType::Terminal [position,outlet,compute_main_digraph]\n// ...\n// ...\nt_outlet compute_main_digraph(vec3 a_pos) {\n\tt_position tmp011 = t_position(a_pos);\n\tt_box_width tmp009 = u_box_width;\n\tt_box_width_top tmp003 = u_box_width_top;\n\tt_modpre_union_outlet tmp013 = compute_modpre_union(tmp011.v_pos);\n\tt_box_position tmp008 = u_box_position;\n\tt_box_position_top tmp002 = u_box_position_top;\n\tt_modpre_translate_outlet tmp017 = compute_modpre_translate(tmp013.v_pos1, vec3(tmp002.v_X, (tmp003.v_Y + tmp002.v_Y), tmp002.v_Z));\n\tt_modpre_translate_outlet tmp015 = compute_modpre_translate(tmp013.v_pos0, vec3(tmp008.v_X, (tmp009.v_Y + tmp008.v_Y), tmp008.v_Z));\n\tvec3 tmp006 = vec3(tmp009.v_X, tmp009.v_Y, tmp009.v_Z);\n\tvec3 tmp004 = vec3(tmp003.v_X, tmp003.v_Y, tmp003.v_Z);\n\tfloat tmp001 = (tmp009.v_Y + tmp008.v_Y);\n\tfloat tmp000 = (tmp003.v_Y + tmp002.v_Y);\n\tvec3 tmp007 = vec3(tmp008.v_X, tmp001, tmp008.v_Z);\n\tvec3 tmp005 = vec3(tmp002.v_X, tmp000, tmp002.v_Z);\n\tt_sdf_box_outlet tmp019 = compute_sdf_box(tmp015.v_pos, tmp006);\n\tt_sdf_box_outlet tmp018 = compute_sdf_box(tmp017.v_pos, tmp004);\n\tt_modpost_translate_outlet tmp016 = compute_modpost_translate(tmp018.v_dist, tmp005);\n\tt_modpost_translate_outlet tmp014 = compute_modpost_translate(tmp019.v_dist, tmp007);\n\tt_modpost_union_outlet tmp012 = compute_modpost_union(tmp014.v_dist, tmp016.v_dist);\n\treturn t_outlet(tmp012.v_dist);\n}\n\nfloat eval_distance(vec3 pos) {\n\treturn compute_main_digraph(pos).v_dist;\n}\nvec3 eval_basecolor(vec3 pos) {\n\treturn vec3(-1.f);\n}\nfloat eval_roughness(vec3 pos) {\n\treturn -1.f;\n}\nfloat eval_metallic(vec3 pos) {\n\treturn -1.f;\n}\n", "box_three": "//// PREAMBLE\n\nfloat opp(float vv) { return -vv; }\n\nfloat vmin(vec2 vv) { return min(vv.x, vv.y); }\nfloat vmin(vec3 vv) { return min(min(vv.x, vv.y), vv.z); }\nfloat vmin(vec4 vv) { return min(min(vv.x, vv.y), min(vv.z, vv.w)); }\n\nfloat vmax(vec2 vv) { return max(vv.x, vv.y); }\nfloat vmax(vec3 vv) { return max(max(vv.x, vv.y), vv.z); }\nfloat vmax(vec4 vv) { return max(max(vv.x, vv.y), max(vv.z, vv.w)); }\n\n// According to the Kronos documentation, the fract of the input is computing\n// in this way 'x-floor(x)' which result to wrong results with negative values.\nfloat fractOfPositiveAndNegativeValue(float vv) {\n  return vv < 0.0 ? vv - ceil(vv) : vv - floor(vv);\n}\nvec2 fractOfPositiveAndNegativeValue(vec2 vv) {\n  return vec2(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y));\n}\nvec3 fractOfPositiveAndNegativeValue(vec3 vv) {\n  return vec3(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z));\n}\nvec4 fractOfPositiveAndNegativeValue(vec4 vv) {\n  return vec4(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z),\n    fractOfPositiveAndNegativeValue(vv.w));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n  float n = dot(i, step);\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec2 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec3 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n// https://www.pcg-random.org/\nfloat noisePcg(float q){\n  uint v = uint(round(q));\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float(float((word >> 22u) ^ word) * (1.0/float(0xffffffffu))) ;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh  \nvec2 noisePcg(vec2 q){\n  uvec2 v = uvec2(q);\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  return vec2(vec2(v)* (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec3 noisePcg(vec3 q){\n  uvec3 v = uvec3(q);\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  \n  return vec3(vec3(v) * (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec4 noisePcg(vec4 q){\n  uvec4 v = uvec4(q);\n  v = v * 1664525u + 1013904223u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  v ^= v >> 16u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  return vec4(vec4(v) * (1.0/float(0xffffffffu)));\n}\n\n\n//// CUSTOM TYPES\n\nstruct t_box_width_top {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_box_position_top {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_box_width_right {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_box_width_left {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_box_position_left {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_box_position_right {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_zero {\n\tfloat v_value;\n};\n\nstruct t_one {\n\tfloat v_value;\n};\n\nstruct t_modpost_union_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n};\nstruct t_modpost_union_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_box_inlet {\n\tvec3 v_pos;\n\tvec3 v_bounding_box;\n};\nstruct t_sdf_box_outlet {\n\tfloat v_dist;\n};\n\nstruct t_position {\n\tvec3 v_pos;\n};\nstruct t_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_translate_inlet {\n\tvec3 v_pos;\n\tvec3 v_offset;\n};\nstruct t_modpre_translate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_translate_inlet {\n\tfloat v_dist;\n\tvec3 v_offset;\n};\nstruct t_modpost_translate_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_union_inlet {\n\tvec3 v_pos;\n};\nstruct t_modpre_union_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\n//// PROTOTYPES\n\n// float operator+(float a_a, float a_b); // FUNCID(126) builtin arithmetic\n// vec3 operator-(vec3 a_a, vec3 a_b); // FUNCID(140) builtin arithmetic\n// float min(float a_a, float a_b); // FUNCID(69) builtin operator\n// float max(float a_a, float a_b); // FUNCID(66) builtin operator\n// float length(vec3 a_i); // FUNCID(59) builtin operator\n// vec3 max(vec3 a_a, vec3 a_b); // FUNCID(67) builtin operator\n// vec3 abs(vec3 a_i); // FUNCID(11) builtin operator\n// vec3 operator*(vec3 a_a, float a_b); // FUNCID(136) builtin arithmetic\nt_modpost_union_outlet compute_modpost_union(float a_dist0, float a_dist1); // FUNCID(166) terminal\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box); // FUNCID(206) terminal\nt_outlet compute_main_digraph(vec3 a_pos); // FUNCID(422) terminal\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset); // FUNCID(286) terminal\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset); // FUNCID(289) terminal\nt_modpre_union_outlet compute_modpre_union(vec3 a_pos); // FUNCID(163) terminal\n\n//// INSTANCES\n\nuniform t_box_width_top u_box_width_top;\nuniform t_box_position_top u_box_position_top;\nuniform t_box_width_right u_box_width_right;\nuniform t_box_width_left u_box_width_left;\nuniform t_box_position_left u_box_position_left;\nuniform t_box_position_right u_box_position_right;\nconst t_zero c_zero = t_zero(float(0));\nconst t_one c_one = t_one(float(1));\n\n//// IMPLEMENTATIONS\n\n// FUNCID(163) 1i->2o ComposeFuncType::Terminal [modpre_union_inlet,modpre_union_outlet,compute_modpre_union]\n// ...\n// ...\nt_modpre_union_outlet compute_modpre_union(vec3 a_pos) {\n\tt_modpre_union_inlet tmp003 = t_modpre_union_inlet(a_pos);\n\tconst t_one tmp001 = c_one;\n\tvec3 tmp000 = (tmp003.v_pos * tmp001.v_value);\n\treturn t_modpre_union_outlet(tmp000, tmp000);\n}\n\n// FUNCID(166) 2i->1o ComposeFuncType::Terminal [modpost_union_inlet,modpost_union_outlet,compute_modpost_union]\n// ...\n// ...\nt_modpost_union_outlet compute_modpost_union(float a_dist0, float a_dist1) {\n\tt_modpost_union_inlet tmp002 = t_modpost_union_inlet(a_dist0, a_dist1);\n\tfloat tmp000 = min(tmp002.v_dist0, tmp002.v_dist1);\n\treturn t_modpost_union_outlet(tmp000);\n}\n\n// FUNCID(206) 2i->1o ComposeFuncType::Terminal [sdf_box_inlet,sdf_box_outlet,compute_sdf_box]\n// ...\n// ...\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box) {\n\tconst t_zero tmp006 = c_zero;\n\tt_sdf_box_inlet tmp000 = t_sdf_box_inlet(a_pos, a_bounding_box);\n\tvec3 tmp002 = abs(tmp000.v_pos);\n\tvec3 tmp004 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp003 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp008 = vec3(tmp006.v_value, tmp006.v_value, tmp006.v_value);\n\tfloat tmp005 = max(tmp004.y, tmp004.z);\n\tconst t_zero tmp012 = c_zero;\n\tfloat tmp010 = max(tmp004.x, tmp005);\n\tvec3 tmp007 = max(tmp008, tmp003);\n\tfloat tmp011 = min(tmp012.v_value, tmp010);\n\tfloat tmp009 = length(tmp007);\n\tfloat tmp013 = (tmp009 + tmp011);\n\treturn t_sdf_box_outlet(tmp013);\n}\n\n// FUNCID(286) 2i->1o ComposeFuncType::Terminal [modpre_translate_inlet,modpre_translate_outlet,compute_modpre_translate]\n// ...\n// ...\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset) {\n\tt_modpre_translate_inlet tmp000 = t_modpre_translate_inlet(a_pos, a_offset);\n\tvec3 tmp002 = (tmp000.v_pos - tmp000.v_offset);\n\treturn t_modpre_translate_outlet(tmp002);\n}\n\n// FUNCID(289) 2i->1o ComposeFuncType::Terminal [modpost_translate_inlet,modpost_translate_outlet,compute_modpost_translate]\n// ...\n// ...\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_translate_inlet tmp000 = t_modpost_translate_inlet(a_dist, a_offset);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_translate_outlet(tmp002);\n}\n\n// FUNCID(422) 1i->1o ComposeFuncType::Terminal [position,outlet,compute_main_digraph]\n// ...\n// ...\nt_outlet compute_main_digraph(vec3 a_pos) {\n\tt_box_width_left tmp014 = u_box_width_left;\n\tt_box_width_top tmp008 = u_box_width_top;\n\tt_modpre_union_outlet tmp020 = compute_modpre_union(compute_modpre_union(t_position(a_pos).v_pos).v_pos0);\n\tt_position tmp016 = t_position(a_pos);\n\tt_box_width_right tmp004 = u_box_width_right;\n\tt_box_position_left tmp013 = u_box_position_left;\n\tt_box_position_top tmp007 = u_box_position_top;\n\tt_modpre_union_outlet tmp018 = compute_modpre_union(tmp016.v_pos);\n\tt_modpre_translate_outlet tmp026 = compute_modpre_translate(tmp020.v_pos1, vec3(tmp007.v_X, (tmp008.v_Y + tmp007.v_Y), tmp007.v_Z));\n\tt_modpre_translate_outlet tmp024 = compute_modpre_translate(tmp020.v_pos0, vec3(tmp013.v_X, (tmp014.v_Y + tmp013.v_Y), tmp013.v_Z));\n\tvec3 tmp011 = vec3(tmp014.v_X, tmp014.v_Y, tmp014.v_Z);\n\tvec3 tmp009 = vec3(tmp008.v_X, tmp008.v_Y, tmp008.v_Z);\n\tfloat tmp002 = (tmp014.v_Y + tmp013.v_Y);\n\tfloat tmp001 = (tmp008.v_Y + tmp007.v_Y);\n\tt_box_position_right tmp003 = u_box_position_right;\n\tvec3 tmp012 = vec3(tmp013.v_X, tmp002, tmp013.v_Z);\n\tvec3 tmp010 = vec3(tmp007.v_X, tmp001, tmp007.v_Z);\n\tt_sdf_box_outlet tmp028 = compute_sdf_box(tmp024.v_pos, tmp011);\n\tt_sdf_box_outlet tmp027 = compute_sdf_box(tmp026.v_pos, tmp009);\n\tt_modpre_translate_outlet tmp022 = compute_modpre_translate(tmp018.v_pos1, vec3(tmp003.v_X, (tmp004.v_Y + tmp003.v_Y), tmp003.v_Z));\n\tvec3 tmp005 = vec3(tmp004.v_X, tmp004.v_Y, tmp004.v_Z);\n\tfloat tmp000 = (tmp004.v_Y + tmp003.v_Y);\n\tvec3 tmp006 = vec3(tmp003.v_X, tmp000, tmp003.v_Z);\n\tt_sdf_box_outlet tmp029 = compute_sdf_box(tmp022.v_pos, tmp005);\n\tt_modpost_translate_outlet tmp025 = compute_modpost_translate(tmp027.v_dist, tmp010);\n\tt_modpost_translate_outlet tmp023 = compute_modpost_translate(tmp028.v_dist, tmp012);\n\tt_modpost_translate_outlet tmp021 = compute_modpost_translate(tmp029.v_dist, tmp006);\n\tt_modpost_union_outlet tmp019 = compute_modpost_union(tmp023.v_dist, tmp025.v_dist);\n\tt_modpost_union_outlet tmp017 = compute_modpost_union(tmp019.v_dist, tmp021.v_dist);\n\treturn t_outlet(tmp017.v_dist);\n}\n\nfloat eval_distance(vec3 pos) {\n\treturn compute_main_digraph(pos).v_dist;\n}\nvec3 eval_basecolor(vec3 pos) {\n\treturn vec3(-1.f);\n}\nfloat eval_roughness(vec3 pos) {\n\treturn -1.f;\n}\nfloat eval_metallic(vec3 pos) {\n\treturn -1.f;\n}\n", "vase_generator_fixbw": "//// PREAMBLE\n\nfloat opp(float vv) { return -vv; }\n\nfloat vmin(vec2 vv) { return min(vv.x, vv.y); }\nfloat vmin(vec3 vv) { return min(min(vv.x, vv.y), vv.z); }\nfloat vmin(vec4 vv) { return min(min(vv.x, vv.y), min(vv.z, vv.w)); }\n\nfloat vmax(vec2 vv) { return max(vv.x, vv.y); }\nfloat vmax(vec3 vv) { return max(max(vv.x, vv.y), vv.z); }\nfloat vmax(vec4 vv) { return max(max(vv.x, vv.y), max(vv.z, vv.w)); }\n\n// According to the Kronos documentation, the fract of the input is computing\n// in this way 'x-floor(x)' which result to wrong results with negative values.\nfloat fractOfPositiveAndNegativeValue(float vv) {\n  return vv < 0.0 ? vv - ceil(vv) : vv - floor(vv);\n}\nvec2 fractOfPositiveAndNegativeValue(vec2 vv) {\n  return vec2(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y));\n}\nvec3 fractOfPositiveAndNegativeValue(vec3 vv) {\n  return vec3(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z));\n}\nvec4 fractOfPositiveAndNegativeValue(vec4 vv) {\n  return vec4(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z),\n    fractOfPositiveAndNegativeValue(vv.w));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n  float n = dot(i, step);\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec2 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec3 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n// https://www.pcg-random.org/\nfloat noisePcg(float q){\n  uint v = uint(round(q));\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float(float((word >> 22u) ^ word) * (1.0/float(0xffffffffu))) ;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh  \nvec2 noisePcg(vec2 q){\n  uvec2 v = uvec2(q);\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  return vec2(vec2(v)* (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec3 noisePcg(vec3 q){\n  uvec3 v = uvec3(q);\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  \n  return vec3(vec3(v) * (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec4 noisePcg(vec4 q){\n  uvec4 v = uvec4(q);\n  v = v * 1664525u + 1013904223u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  v ^= v >> 16u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  return vec4(vec4(v) * (1.0/float(0xffffffffu)));\n}\n\n\n//// CUSTOM TYPES\n\nstruct t_two {\n\tfloat v_value;\n};\n\nstruct t_dimension {\n\tfloat v_height;\n\tfloat v_radius;\n\tfloat v_thickness;\n\tfloat v_offset;\n\tfloat v_fac;\n};\n\nstruct t_mat {\n\tfloat v_min_rough;\n\tfloat v_max_rough;\n\tfloat v_col;\n\tvec3 v_aniso;\n};\n\nstruct t_minus_one {\n\tfloat v_value;\n};\n\nstruct t_zero {\n\tfloat v_value;\n};\n\nstruct t_one {\n\tfloat v_value;\n};\n\nstruct t_morph_input {\n\tfloat v_box;\n\tfloat v_hex;\n\tfloat v_cone;\n\tfloat v_sphere;\n\tfloat v_sphere_scale;\n\tfloat v_sphere_smooth;\n\tfloat v_sphere_offset;\n};\n\nstruct t_hexagonal_prism_const {\n\tvec3 v_o0;\n};\n\nstruct t_deformation {\n\tfloat v_grad_top;\n\tfloat v_grad_top_int;\n\tfloat v_grad_bot;\n\tfloat v_grad_bot_int;\n};\n\nstruct t_vase_const {\n\tfloat v_factor;\n};\n\nstruct t_half {\n\tfloat v_value;\n};\n\nstruct t_epsilon {\n\tfloat v_epsilon;\n};\n\nstruct t_sdf_box_inlet {\n\tvec3 v_pos;\n\tvec3 v_bounding_box;\n};\nstruct t_sdf_box_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_sphere_inlet {\n\tvec3 v_pos;\n\tfloat v_radius;\n};\nstruct t_sdf_sphere_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpost_smooth_union_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n\tfloat v_factor;\n};\nstruct t_modpost_smooth_union_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_cone_inlet {\n\tvec3 v_pos;\n\tfloat v_height;\n\tfloat v_radius;\n};\nstruct t_sdf_cone_outlet {\n\tfloat v_dist;\n};\n\nstruct t_position {\n\tvec3 v_pos;\n};\nstruct t_outlet {\n\tfloat v_dist;\n\tvec3 v_basecolor;\n\tfloat v_roughness;\n\tfloat v_metallic;\n};\n\nstruct t_sdf_plane_inlet {\n\tvec3 v_pos;\n\tvec3 v_normal;\n\tfloat v_offset;\n};\nstruct t_sdf_plane_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_morph_inlet {\n\tvec3 v_pos;\n\tfloat v_factor;\n};\nstruct t_modpre_morph_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\nstruct t_sdf_cylinder_inlet {\n\tvec3 v_pos;\n\tfloat v_height;\n\tfloat v_radius;\n};\nstruct t_sdf_cylinder_outlet {\n\tfloat v_dist;\n};\n\nstruct t_gradient_y_inlet {\n\tvec3 v_pos;\n\tfloat v_height;\n\tfloat v_min;\n\tfloat v_max;\n};\nstruct t_gradient_y_outlet {\n\tfloat v_o0;\n};\n\nstruct t_sdf_hexagonal_prism_inlet {\n\tvec3 v_pos;\n\tfloat v_radius;\n\tfloat v_height;\n};\nstruct t_sdf_hexagonal_prism_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpost_morph_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n\tfloat v_factor;\n};\nstruct t_modpost_morph_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_translate_inlet {\n\tvec3 v_pos;\n\tvec3 v_offset;\n};\nstruct t_modpre_translate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_translate_inlet {\n\tfloat v_dist;\n\tvec3 v_offset;\n};\nstruct t_modpost_translate_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_difference_inlet {\n\tvec3 v_pos;\n};\nstruct t_modpre_difference_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\nstruct t_modpost_difference_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n};\nstruct t_modpost_difference_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_directional_displacement_inlet {\n\tvec3 v_pos;\n\tfloat v_mask;\n\tvec3 v_intensity;\n};\nstruct t_modpre_directional_displacement_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_directional_displacement_inlet {\n\tfloat v_dist;\n\tfloat v_mask;\n\tvec3 v_intensity;\n};\nstruct t_modpost_directional_displacement_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_smooth_union_inlet {\n\tvec3 v_pos;\n\tfloat v_factor;\n};\nstruct t_modpre_smooth_union_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\nstruct t_modpre_shell_inlet {\n\tvec3 v_pos;\n\tfloat v_thickness;\n};\nstruct t_modpre_shell_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_shell_inlet {\n\tfloat v_dist;\n\tfloat v_thickness;\n};\nstruct t_modpost_shell_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_smooth_difference_inlet {\n\tvec3 v_pos;\n\tfloat v_factor;\n};\nstruct t_modpre_smooth_difference_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\nstruct t_modpost_smooth_difference_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n\tfloat v_factor;\n};\nstruct t_modpost_smooth_difference_outlet {\n\tfloat v_dist;\n};\n\nstruct t_float_to_vec3_inlet {\n\tfloat v_i0;\n};\nstruct t_float_to_vec3_outlet {\n\tvec3 v_o0;\n};\n\nstruct t_mat_metal_brushed_inlet {\n\tvec3 v_position;\n\tvec3 v_basecolor;\n\tfloat v_min_roughness;\n\tfloat v_max_roughness;\n\tvec3 v_noise_scale;\n};\nstruct t_mat_metal_brushed_outlet {\n\tvec3 v_basecolor;\n\tfloat v_roughness;\n\tfloat v_metallic;\n};\n\nstruct t_float_to_xz_vec3_inlet {\n\tfloat v_i0;\n};\nstruct t_float_to_xz_vec3_outlet {\n\tvec3 v_o0;\n};\n\n//// PROTOTYPES\n\n// float abs(float a_i); // FUNCID(4) builtin operator\n// vec2 max(vec2 a_a, vec2 a_b); // FUNCID(52) builtin operator\n// float operator*(float a_a, float a_b); // FUNCID(116) builtin arithmetic\n// float fbm(vec3 a_a, float a_b); // FUNCID(352) builtin operator\n// float operator+(float a_a, float a_b); // FUNCID(111) builtin arithmetic\n// float operator/(float a_a, float a_b); // FUNCID(6) builtin arithmetic\n// float min(float a_a, float a_b); // FUNCID(60) builtin operator\n// vec2 operator-(vec2 a_a, vec2 a_b); // FUNCID(124) builtin arithmetic\n// float operator-(float a_a, float a_b); // FUNCID(123) builtin arithmetic\n// vec3 max(vec3 a_a, vec3 a_b); // FUNCID(58) builtin operator\n// vec3 (vec3 a_i); // FUNCID(385) builtin operator\n// float mix(float a_x, float a_y, float a_z); // FUNCID(25) builtin operator\n// float length(vec2 a_i); // FUNCID(49) builtin operator\n// vec3 operator*(vec3 a_a, vec3 a_b); // FUNCID(109) builtin arithmetic\n// float atan(float a_y, float a_x); // FUNCID(103) builtin operator\n// float max(float a_a, float a_b); // FUNCID(57) builtin operator\n// vec3 operator*(vec3 a_a, float a_b); // FUNCID(121) builtin arithmetic\n// vec2 operator*(vec2 a_a, vec2 a_b); // FUNCID(117) builtin arithmetic\n// float sign(float a_i); // FUNCID(77) builtin operator\n// float clamp(float a_x, float a_y, float a_z); // FUNCID(31) builtin operator\n// float dot(vec2 a_a, vec2 a_b); // FUNCID(37) builtin operator\n// vec3 abs(vec3 a_i); // FUNCID(11) builtin operator\n// float smoothstep(float a_x, float a_y, float a_z); // FUNCID(82) builtin operator\n// vec3 operator-(vec3 a_a, vec3 a_b); // FUNCID(125) builtin arithmetic\n// float opp(float a_i); // FUNCID(21) builtin operator\n// float sqrt(float a_i); // FUNCID(86) builtin operator\n// vec2 operator*(vec2 a_a, float a_b); // FUNCID(56) builtin arithmetic\n// float vmax(vec2 a_i); // FUNCID(75) builtin operator\n// vec2 abs(vec2 a_i); // FUNCID(3) builtin operator\n// vec3 normalize(vec3 a_i); // FUNCID(69) builtin operator\n// float dot(vec3 a_a, vec3 a_b); // FUNCID(38) builtin operator\n// float length(vec3 a_i); // FUNCID(50) builtin operator\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box); // FUNCID(137) terminal\nt_sdf_sphere_outlet compute_sdf_sphere(vec3 a_pos, float a_radius); // FUNCID(145) terminal\nt_modpost_smooth_union_outlet compute_modpost_smooth_union(float a_dist0, float a_dist1, float a_factor); // FUNCID(217) terminal\nt_sdf_cone_outlet compute_sdf_cone(vec3 a_pos, float a_height, float a_radius); // FUNCID(153) terminal\nt_outlet compute_main_digraph(vec3 a_pos); // FUNCID(346) terminal\nt_sdf_plane_outlet compute_sdf_plane(vec3 a_pos, vec3 a_normal, float a_offset); // FUNCID(161) terminal\nt_modpre_morph_outlet compute_modpre_morph(vec3 a_pos, float a_factor); // FUNCID(326) terminal\nt_sdf_cylinder_outlet compute_sdf_cylinder(vec3 a_pos, float a_height, float a_radius); // FUNCID(165) terminal\nt_gradient_y_outlet compute_gradient_y(vec3 a_pos, float a_height, float a_min, float a_max); // FUNCID(374) terminal\nt_sdf_hexagonal_prism_outlet compute_sdf_hexagonal_prism(vec3 a_pos, float a_radius, float a_height); // FUNCID(189) terminal\nt_modpost_morph_outlet compute_modpost_morph(float a_dist0, float a_dist1, float a_factor); // FUNCID(329) terminal\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset); // FUNCID(221) terminal\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset); // FUNCID(224) terminal\nt_modpre_difference_outlet compute_modpre_difference(vec3 a_pos); // FUNCID(200) terminal\nt_modpost_difference_outlet compute_modpost_difference(float a_dist0, float a_dist1); // FUNCID(203) terminal\nt_modpre_directional_displacement_outlet compute_modpre_directional_displacement(vec3 a_pos, float a_mask, vec3 a_intensity); // FUNCID(333) terminal\nt_modpost_directional_displacement_outlet compute_modpost_directional_displacement(float a_dist, float a_mask, vec3 a_intensity); // FUNCID(336) terminal\nt_modpre_smooth_union_outlet compute_modpre_smooth_union(vec3 a_pos, float a_factor); // FUNCID(214) terminal\nt_modpre_shell_outlet compute_modpre_shell(vec3 a_pos, float a_thickness); // FUNCID(298) terminal\nt_modpost_shell_outlet compute_modpost_shell(float a_dist, float a_thickness); // FUNCID(301) terminal\nt_modpre_smooth_difference_outlet compute_modpre_smooth_difference(vec3 a_pos, float a_factor); // FUNCID(305) terminal\nt_modpost_smooth_difference_outlet compute_modpost_smooth_difference(float a_dist0, float a_dist1, float a_factor); // FUNCID(308) terminal\nt_float_to_vec3_outlet compute_float_to_vec3(float a_i0); // FUNCID(368) terminal\nt_mat_metal_brushed_outlet compute_mat_metal_brushed(vec3 a_position, vec3 a_basecolor, float a_min_roughness, float a_max_roughness, vec3 a_noise_scale); // FUNCID(380) terminal\nt_float_to_xz_vec3_outlet compute_float_to_xz_vec3(float a_i0); // FUNCID(391) terminal\n\n//// INSTANCES\n\nconst t_two c_two = t_two(float(2));\nuniform t_dimension u_dimension;\nuniform t_mat u_mat;\nconst t_minus_one c_minus_one = t_minus_one(float(-1));\nconst t_zero c_zero = t_zero(float(0));\nconst t_one c_one = t_one(float(1));\nuniform t_morph_input u_morph_input;\nconst t_hexagonal_prism_const c_hexagonal_prism_const = t_hexagonal_prism_const(vec3(-0.8660254, 0.5, 0.57735));\nuniform t_deformation u_deformation;\nconst t_vase_const c_vase_const = t_vase_const(float(0.005));\nconst t_half c_half = t_half(float(0.5));\nconst t_epsilon c_epsilon = t_epsilon(float(1e-08));\n\n//// IMPLEMENTATIONS\n\n// FUNCID(137) 2i->1o ComposeFuncType::Terminal [sdf_box_inlet,sdf_box_outlet,compute_sdf_box]\n// ...\n// ...\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box) {\n\tconst t_zero tmp006 = c_zero;\n\tt_sdf_box_inlet tmp000 = t_sdf_box_inlet(a_pos, a_bounding_box);\n\tvec3 tmp002 = abs(tmp000.v_pos);\n\tvec3 tmp004 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp003 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp008 = vec3(tmp006.v_value, tmp006.v_value, tmp006.v_value);\n\tfloat tmp005 = max(tmp004.y, tmp004.z);\n\tconst t_zero tmp012 = c_zero;\n\tfloat tmp010 = max(tmp004.x, tmp005);\n\tvec3 tmp007 = max(tmp008, tmp003);\n\tfloat tmp011 = min(tmp012.v_value, tmp010);\n\tfloat tmp009 = length(tmp007);\n\tfloat tmp013 = (tmp009 + tmp011);\n\treturn t_sdf_box_outlet(tmp013);\n}\n\n// FUNCID(145) 2i->1o ComposeFuncType::Terminal [sdf_sphere_inlet,sdf_sphere_outlet,compute_sdf_sphere]\n// ...\n// ...\nt_sdf_sphere_outlet compute_sdf_sphere(vec3 a_pos, float a_radius) {\n\tt_sdf_sphere_inlet tmp000 = t_sdf_sphere_inlet(a_pos, a_radius);\n\tfloat tmp002 = length(tmp000.v_pos);\n\tfloat tmp003 = (tmp002 - tmp000.v_radius);\n\treturn t_sdf_sphere_outlet(tmp003);\n}\n\n// FUNCID(153) 3i->1o ComposeFuncType::Terminal [sdf_cone_inlet,sdf_cone_outlet,compute_sdf_cone]\n// ...\n// ...\nt_sdf_cone_outlet compute_sdf_cone(vec3 a_pos, float a_height, float a_radius) {\n\tfloat tmp010 = dot((vec2((t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), c_minus_one.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), vec2(length(vec2(t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.z)), (t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.y - t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height)));\n\tfloat tmp011 = dot((vec2((t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), c_minus_one.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), (vec2((t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), c_minus_one.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height));\n\tfloat tmp019 = (length(vec2(t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.z)) / (vec2((t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height), c_minus_one.v_value) * t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height).x);\n\tfloat tmp020 = clamp(tmp019, c_zero.v_value, c_one.v_value);\n\tfloat tmp012 = (tmp010 / tmp011);\n\tconst t_one tmp015 = c_one;\n\tfloat tmp002 = (t_sdf_cone_inlet(a_pos, a_height, a_radius).v_radius / t_sdf_cone_inlet(a_pos, a_height, a_radius).v_height);\n\tconst t_minus_one tmp003 = c_minus_one;\n\tconst t_zero tmp014 = c_zero;\n\tfloat tmp013 = clamp(tmp012, tmp014.v_value, tmp015.v_value);\n\tvec2 tmp021 = vec2(tmp020, tmp015.v_value);\n\tvec2 tmp004 = vec2(tmp002, tmp003.v_value);\n\tvec2 tmp007 = vec2(t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cone_inlet(a_pos, a_height, a_radius).v_pos.z);\n\tt_sdf_cone_inlet tmp000 = t_sdf_cone_inlet(a_pos, a_height, a_radius);\n\tvec2 tmp005 = (tmp004 * tmp000.v_height);\n\tvec2 tmp016 = (tmp005 * tmp013);\n\tvec2 tmp009 = vec2(length(tmp007), (tmp000.v_pos.y - tmp000.v_height));\n\tfloat tmp008 = length(tmp007);\n\tvec3 tmp006 = tmp000.v_pos;\n\tvec2 tmp022 = (tmp005 * tmp021);\n\tvec2 tmp018 = tmp005;\n\tfloat tmp038 = (tmp006.y - tmp000.v_height);\n\tfloat tmp032 = (tmp018.x * tmp038);\n\tfloat tmp031 = (tmp008 * tmp018.y);\n\tvec2 tmp017 = (tmp009 - tmp016);\n\tvec2 tmp023 = (tmp009 - tmp022);\n\tfloat tmp025 = dot(tmp017, tmp017);\n\tfloat tmp026 = dot(tmp023, tmp023);\n\tfloat tmp028 = (tmp038 - tmp018.y);\n\tfloat tmp033 = (tmp031 - tmp032);\n\tfloat tmp024 = sign(tmp018.y);\n\tfloat tmp027 = min(tmp025, tmp026);\n\tfloat tmp029 = (tmp024 * tmp028);\n\tfloat tmp034 = (tmp024 * tmp033);\n\tconst t_epsilon tmp040 = c_epsilon;\n\tfloat tmp039 = (tmp027 + tmp040.v_epsilon);\n\tfloat tmp030 = max(tmp029, tmp034);\n\tfloat tmp036 = sqrt(tmp039);\n\tfloat tmp035 = sign(tmp030);\n\tfloat tmp037 = (tmp036 * tmp035);\n\treturn t_sdf_cone_outlet(tmp037);\n}\n\n// FUNCID(161) 3i->1o ComposeFuncType::Terminal [sdf_plane_inlet,sdf_plane_outlet,compute_sdf_plane]\n// ...\n// ...\nt_sdf_plane_outlet compute_sdf_plane(vec3 a_pos, vec3 a_normal, float a_offset) {\n\tvec3 tmp003 = normalize(t_sdf_plane_inlet(a_pos, a_normal, a_offset).v_normal);\n\tt_sdf_plane_inlet tmp000 = t_sdf_plane_inlet(a_pos, a_normal, a_offset);\n\tfloat tmp002 = dot(tmp000.v_pos, tmp003);\n\tfloat tmp004 = (tmp002 - tmp000.v_offset);\n\treturn t_sdf_plane_outlet(tmp004);\n}\n\n// FUNCID(165) 3i->1o ComposeFuncType::Terminal [sdf_cylinder_inlet,sdf_cylinder_outlet,compute_sdf_cylinder]\n// ...\n// ...\nt_sdf_cylinder_outlet compute_sdf_cylinder(vec3 a_pos, float a_height, float a_radius) {\n\tvec2 tmp003 = vec2(t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos.z);\n\tvec3 tmp002 = t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos;\n\tfloat tmp004 = length(tmp003);\n\tt_sdf_cylinder_inlet tmp000 = t_sdf_cylinder_inlet(a_pos, a_height, a_radius);\n\tvec2 tmp006 = vec2(tmp004, tmp002.y);\n\tvec2 tmp007 = abs(tmp006);\n\tvec2 tmp005 = vec2(tmp000.v_radius, tmp000.v_height);\n\tvec2 tmp008 = (tmp007 - tmp005);\n\tvec2 tmp013 = vec2(c_zero.v_value, c_zero.v_value);\n\tconst t_zero tmp010 = c_zero;\n\tvec2 tmp012 = max(tmp008, tmp013);\n\tfloat tmp009 = vmax(tmp008);\n\tfloat tmp015 = length(tmp012);\n\tfloat tmp011 = min(tmp009, tmp010.v_value);\n\tfloat tmp014 = (tmp011 + tmp015);\n\treturn t_sdf_cylinder_outlet(tmp014);\n}\n\n// FUNCID(189) 3i->1o ComposeFuncType::Terminal [sdf_hexagonal_prism_inlet,sdf_hexagonal_prism_outlet,compute_sdf_hexagonal_prism]\n// ...\n// ...\nt_sdf_hexagonal_prism_outlet compute_sdf_hexagonal_prism(vec3 a_pos, float a_radius, float a_height) {\n\tfloat tmp009 = dot(vec2(c_hexagonal_prism_const.v_o0.x, c_hexagonal_prism_const.v_o0.y), vec2(abs(t_sdf_hexagonal_prism_inlet(a_pos, a_radius, a_height).v_pos).x, abs(t_sdf_hexagonal_prism_inlet(a_pos, a_radius, a_height).v_pos).z));\n\tconst t_zero tmp010 = c_zero;\n\tconst t_minus_one tmp015 = c_minus_one;\n\tconst t_two tmp008 = c_two;\n\tfloat tmp011 = min(tmp009, tmp010.v_value);\n\tconst t_hexagonal_prism_const tmp002 = c_hexagonal_prism_const;\n\tvec3 tmp007 = tmp002.v_o0;\n\tfloat tmp033 = (tmp008.v_value * tmp011);\n\tfloat tmp014 = (tmp007.z * tmp015.v_value);\n\tvec2 tmp006 = vec2(tmp007.x, tmp007.y);\n\tvec2 tmp034 = vec2(tmp033, tmp033);\n\tfloat tmp017 = (t_sdf_hexagonal_prism_inlet(a_pos, a_radius, a_height).v_radius * tmp007.z);\n\tfloat tmp016 = (t_sdf_hexagonal_prism_inlet(a_pos, a_radius, a_height).v_radius * tmp014);\n\tvec2 tmp005 = vec2(abs(t_sdf_hexagonal_prism_inlet(a_pos, a_radius, a_height).v_pos).x, abs(t_sdf_hexagonal_prism_inlet(a_pos, a_radius, a_height).v_pos).z);\n\tvec2 tmp035 = (tmp034 * tmp006);\n\tfloat tmp013 = clamp((tmp005 - tmp035).x, tmp016, tmp017);\n\tvec2 tmp022 = vec2(tmp013, t_sdf_hexagonal_prism_inlet(a_pos, a_radius, a_height).v_radius);\n\tvec2 tmp032 = (tmp005 - tmp035);\n\tvec2 tmp036 = tmp032;\n\tfloat tmp019 = (tmp036.y - t_sdf_hexagonal_prism_inlet(a_pos, a_radius, a_height).v_radius);\n\tvec2 tmp021 = (tmp032 - tmp022);\n\tvec3 tmp003 = abs(t_sdf_hexagonal_prism_inlet(a_pos, a_radius, a_height).v_pos);\n\tfloat tmp018 = sign(tmp019);\n\tfloat tmp012 = length(tmp021);\n\tt_sdf_hexagonal_prism_inlet tmp000 = t_sdf_hexagonal_prism_inlet(a_pos, a_radius, a_height);\n\tvec3 tmp004 = tmp003;\n\tfloat tmp024 = (tmp012 * tmp018);\n\tfloat tmp020 = (tmp004.y - tmp000.v_height);\n\tvec2 tmp030 = vec2(c_zero.v_value, c_zero.v_value);\n\tvec2 tmp023 = vec2(tmp024, tmp020);\n\tconst t_zero tmp027 = c_zero;\n\tfloat tmp026 = max(tmp024, tmp020);\n\tvec2 tmp029 = max(tmp023, tmp030);\n\tfloat tmp031 = length(tmp029);\n\tfloat tmp025 = min(tmp026, tmp027.v_value);\n\tfloat tmp028 = (tmp025 + tmp031);\n\treturn t_sdf_hexagonal_prism_outlet(tmp028);\n}\n\n// FUNCID(200) 1i->2o ComposeFuncType::Terminal [modpre_difference_inlet,modpre_difference_outlet,compute_modpre_difference]\n// ...\n// ...\nt_modpre_difference_outlet compute_modpre_difference(vec3 a_pos) {\n\tconst t_one tmp002 = c_one;\n\tt_modpre_difference_inlet tmp000 = t_modpre_difference_inlet(a_pos);\n\tvec3 tmp003 = (tmp000.v_pos * tmp002.v_value);\n\treturn t_modpre_difference_outlet(tmp003, tmp003);\n}\n\n// FUNCID(203) 2i->1o ComposeFuncType::Terminal [modpost_difference_inlet,modpost_difference_outlet,compute_modpost_difference]\n// ...\n// ...\nt_modpost_difference_outlet compute_modpost_difference(float a_dist0, float a_dist1) {\n\tt_modpost_difference_inlet tmp000 = t_modpost_difference_inlet(a_dist0, a_dist1);\n\tfloat tmp002 = opp(tmp000.v_dist1);\n\tfloat tmp003 = max(tmp000.v_dist0, tmp002);\n\treturn t_modpost_difference_outlet(tmp003);\n}\n\n// FUNCID(214) 2i->2o ComposeFuncType::Terminal [modpre_smooth_union_inlet,modpre_smooth_union_outlet,compute_modpre_smooth_union]\n// ...\n// ...\nt_modpre_smooth_union_outlet compute_modpre_smooth_union(vec3 a_pos, float a_factor) {\n\tconst t_one tmp002 = c_one;\n\tt_modpre_smooth_union_inlet tmp000 = t_modpre_smooth_union_inlet(a_pos, a_factor);\n\tvec3 tmp003 = (tmp000.v_pos * tmp002.v_value);\n\treturn t_modpre_smooth_union_outlet(tmp003, tmp003);\n}\n\n// FUNCID(217) 3i->1o ComposeFuncType::Terminal [modpost_smooth_union_inlet,modpost_smooth_union_outlet,compute_modpost_smooth_union]\n// ...\n// ...\nt_modpost_smooth_union_outlet compute_modpost_smooth_union(float a_dist0, float a_dist1, float a_factor) {\n\tfloat tmp002 = (t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor).v_dist0 - t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor).v_dist1);\n\tfloat tmp014 = abs(tmp002);\n\tconst t_zero tmp005 = c_zero;\n\tfloat tmp003 = (t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor).v_factor - tmp014);\n\tfloat tmp004 = max(tmp003, tmp005.v_value);\n\tfloat tmp006 = (tmp004 / t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor).v_factor);\n\tconst t_half tmp010 = c_half;\n\tfloat tmp008 = (tmp006 * tmp006);\n\tt_modpost_smooth_union_inlet tmp000 = t_modpost_smooth_union_inlet(a_dist0, a_dist1, a_factor);\n\tfloat tmp011 = (tmp010.v_value * tmp010.v_value);\n\tfloat tmp009 = (tmp008 * tmp000.v_factor);\n\tfloat tmp012 = (tmp009 * tmp011);\n\tfloat tmp007 = min(tmp000.v_dist0, tmp000.v_dist1);\n\tfloat tmp013 = (tmp007 - tmp012);\n\treturn t_modpost_smooth_union_outlet(tmp013);\n}\n\n// FUNCID(221) 2i->1o ComposeFuncType::Terminal [modpre_translate_inlet,modpre_translate_outlet,compute_modpre_translate]\n// ...\n// ...\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset) {\n\tt_modpre_translate_inlet tmp000 = t_modpre_translate_inlet(a_pos, a_offset);\n\tvec3 tmp002 = (tmp000.v_pos - tmp000.v_offset);\n\treturn t_modpre_translate_outlet(tmp002);\n}\n\n// FUNCID(224) 2i->1o ComposeFuncType::Terminal [modpost_translate_inlet,modpost_translate_outlet,compute_modpost_translate]\n// ...\n// ...\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_translate_inlet tmp000 = t_modpost_translate_inlet(a_dist, a_offset);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_translate_outlet(tmp002);\n}\n\n// FUNCID(298) 2i->1o ComposeFuncType::Terminal [modpre_shell_inlet,modpre_shell_outlet,compute_modpre_shell]\n// ...\n// ...\nt_modpre_shell_outlet compute_modpre_shell(vec3 a_pos, float a_thickness) {\n\tconst t_one tmp003 = c_one;\n\tt_modpre_shell_inlet tmp000 = t_modpre_shell_inlet(a_pos, a_thickness);\n\tvec3 tmp002 = (tmp000.v_pos * tmp003.v_value);\n\treturn t_modpre_shell_outlet(tmp002);\n}\n\n// FUNCID(301) 2i->1o ComposeFuncType::Terminal [modpost_shell_inlet,modpost_shell_outlet,compute_modpost_shell]\n// ...\n// ...\nt_modpost_shell_outlet compute_modpost_shell(float a_dist, float a_thickness) {\n\tt_modpost_shell_inlet tmp000 = t_modpost_shell_inlet(a_dist, a_thickness);\n\tfloat tmp002 = abs(tmp000.v_dist);\n\tfloat tmp003 = (tmp002 - tmp000.v_thickness);\n\treturn t_modpost_shell_outlet(tmp003);\n}\n\n// FUNCID(305) 2i->2o ComposeFuncType::Terminal [modpre_smooth_difference_inlet,modpre_smooth_difference_outlet,compute_modpre_smooth_difference]\n// ...\n// ...\nt_modpre_smooth_difference_outlet compute_modpre_smooth_difference(vec3 a_pos, float a_factor) {\n\tconst t_one tmp002 = c_one;\n\tt_modpre_smooth_difference_inlet tmp000 = t_modpre_smooth_difference_inlet(a_pos, a_factor);\n\tvec3 tmp003 = (tmp000.v_pos * tmp002.v_value);\n\treturn t_modpre_smooth_difference_outlet(tmp003, tmp003);\n}\n\n// FUNCID(308) 3i->1o ComposeFuncType::Terminal [modpost_smooth_difference_inlet,modpost_smooth_difference_outlet,compute_modpost_smooth_difference]\n// ...\n// ...\nt_modpost_smooth_difference_outlet compute_modpost_smooth_difference(float a_dist0, float a_dist1, float a_factor) {\n\tfloat tmp016 = opp(t_modpost_smooth_difference_inlet(a_dist0, a_dist1, a_factor).v_dist0);\n\tfloat tmp002 = (tmp016 - t_modpost_smooth_difference_inlet(a_dist0, a_dist1, a_factor).v_dist1);\n\tfloat tmp012 = abs(tmp002);\n\tconst t_zero tmp005 = c_zero;\n\tfloat tmp003 = (t_modpost_smooth_difference_inlet(a_dist0, a_dist1, a_factor).v_factor - tmp012);\n\tfloat tmp004 = max(tmp003, tmp005.v_value);\n\tfloat tmp006 = (tmp004 / t_modpost_smooth_difference_inlet(a_dist0, a_dist1, a_factor).v_factor);\n\tconst t_half tmp009 = c_half;\n\tfloat tmp007 = (tmp006 * tmp006);\n\tt_modpost_smooth_difference_inlet tmp000 = t_modpost_smooth_difference_inlet(a_dist0, a_dist1, a_factor);\n\tfloat tmp015 = opp(tmp000.v_dist1);\n\tfloat tmp010 = (tmp009.v_value * tmp009.v_value);\n\tfloat tmp008 = (tmp007 * tmp000.v_factor);\n\tfloat tmp013 = max(tmp000.v_dist0, tmp015);\n\tfloat tmp011 = (tmp008 * tmp010);\n\tfloat tmp014 = (tmp013 + tmp011);\n\treturn t_modpost_smooth_difference_outlet(tmp014);\n}\n\n// FUNCID(326) 2i->2o ComposeFuncType::Terminal [modpre_morph_inlet,modpre_morph_outlet,compute_modpre_morph]\n// ...\n// ...\nt_modpre_morph_outlet compute_modpre_morph(vec3 a_pos, float a_factor) {\n\tconst t_one tmp003 = c_one;\n\tt_modpre_morph_inlet tmp000 = t_modpre_morph_inlet(a_pos, a_factor);\n\tvec3 tmp002 = (tmp000.v_pos * tmp003.v_value);\n\treturn t_modpre_morph_outlet(tmp002, tmp002);\n}\n\n// FUNCID(329) 3i->1o ComposeFuncType::Terminal [modpost_morph_inlet,modpost_morph_outlet,compute_modpost_morph]\n// ...\n// ...\nt_modpost_morph_outlet compute_modpost_morph(float a_dist0, float a_dist1, float a_factor) {\n\tt_modpost_morph_inlet tmp000 = t_modpost_morph_inlet(a_dist0, a_dist1, a_factor);\n\tfloat tmp002 = mix(tmp000.v_dist0, tmp000.v_dist1, tmp000.v_factor);\n\treturn t_modpost_morph_outlet(tmp002);\n}\n\n// FUNCID(333) 3i->1o ComposeFuncType::Terminal [modpre_directional_displacement_inlet,modpre_directional_displacement_outlet,compute_modpre_directional_displacement]\n// ...\n// ...\nt_modpre_directional_displacement_outlet compute_modpre_directional_displacement(vec3 a_pos, float a_mask, vec3 a_intensity) {\n\tvec3 tmp002 = (t_modpre_directional_displacement_inlet(a_pos, a_mask, a_intensity).v_pos * t_modpre_directional_displacement_inlet(a_pos, a_mask, a_intensity).v_intensity);\n\tt_modpre_directional_displacement_inlet tmp000 = t_modpre_directional_displacement_inlet(a_pos, a_mask, a_intensity);\n\tvec3 tmp004 = (tmp002 * tmp000.v_mask);\n\tvec3 tmp003 = (tmp000.v_pos - tmp004);\n\treturn t_modpre_directional_displacement_outlet(tmp003);\n}\n\n// FUNCID(336) 3i->1o ComposeFuncType::Terminal [modpost_directional_displacement_inlet,modpost_directional_displacement_outlet,compute_modpost_directional_displacement]\n// ...\n// ...\nt_modpost_directional_displacement_outlet compute_modpost_directional_displacement(float a_dist, float a_mask, vec3 a_intensity) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_directional_displacement_inlet tmp000 = t_modpost_directional_displacement_inlet(a_dist, a_mask, a_intensity);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_directional_displacement_outlet(tmp002);\n}\n\n// FUNCID(368) 1i->1o ComposeFuncType::Terminal [float_to_vec3_inlet,float_to_vec3_outlet,compute_float_to_vec3]\n// ...\n// ...\nt_float_to_vec3_outlet compute_float_to_vec3(float a_i0) {\n\tt_float_to_vec3_inlet tmp002 = t_float_to_vec3_inlet(a_i0);\n\tvec3 tmp000 = vec3(tmp002.v_i0, tmp002.v_i0, tmp002.v_i0);\n\treturn t_float_to_vec3_outlet(tmp000);\n}\n\n// FUNCID(374) 4i->1o ComposeFuncType::Terminal [gradient_y_inlet,gradient_y_outlet,compute_gradient_y]\n// ...\n// ...\nt_gradient_y_outlet compute_gradient_y(vec3 a_pos, float a_height, float a_min, float a_max) {\n\tvec3 tmp002 = t_gradient_y_inlet(a_pos, a_height, a_min, a_max).v_pos;\n\tconst t_one tmp007 = c_one;\n\tfloat tmp006 = (tmp002.y / t_gradient_y_inlet(a_pos, a_height, a_min, a_max).v_height);\n\tfloat tmp005 = (tmp006 + tmp007.v_value);\n\tconst t_half tmp004 = c_half;\n\tt_gradient_y_inlet tmp000 = t_gradient_y_inlet(a_pos, a_height, a_min, a_max);\n\tfloat tmp003 = (tmp005 * tmp004.v_value);\n\tfloat tmp008 = smoothstep(tmp000.v_min, tmp000.v_max, tmp003);\n\treturn t_gradient_y_outlet(tmp008);\n}\n\n// FUNCID(380) 5i->3o ComposeFuncType::Terminal [mat_metal_brushed_inlet,mat_metal_brushed_outlet,compute_mat_metal_brushed]\n// ...\n// ...\nt_mat_metal_brushed_outlet compute_mat_metal_brushed(vec3 a_position, vec3 a_basecolor, float a_min_roughness, float a_max_roughness, vec3 a_noise_scale) {\n\tconst t_zero tmp009 = c_zero;\n\tvec2 tmp008 = vec2(tmp009.v_value, tmp009.v_value);\n\tvec2 tmp007 = vec2(t_mat_metal_brushed_inlet(a_position, a_basecolor, a_min_roughness, a_max_roughness, a_noise_scale).v_position.x, t_mat_metal_brushed_inlet(a_position, a_basecolor, a_min_roughness, a_max_roughness, a_noise_scale).v_position.z);\n\tvec2 tmp010 = (tmp007 - tmp008);\n\tvec3 tmp002 = t_mat_metal_brushed_inlet(a_position, a_basecolor, a_min_roughness, a_max_roughness, a_noise_scale).v_position;\n\tvec3 tmp014 = t_mat_metal_brushed_inlet(a_position, a_basecolor, a_min_roughness, a_max_roughness, a_noise_scale).v_noise_scale;\n\tfloat tmp006 = length(tmp010);\n\tfloat tmp003 = atan(tmp002.x, tmp002.z);\n\tvec3 tmp015 = vec3(tmp014.x, tmp014.y, tmp014.z);\n\tvec3 tmp004 = vec3(tmp003, tmp002.y, tmp006);\n\tconst t_one tmp012 = c_one;\n\tvec3 tmp005 = (tmp004 * tmp015);\n\tt_mat_metal_brushed_inlet tmp000 = t_mat_metal_brushed_inlet(a_position, a_basecolor, a_min_roughness, a_max_roughness, a_noise_scale);\n\tfloat tmp011 = fbm(tmp005, tmp012.v_value);\n\tvec3 tmp017 = (tmp000.v_basecolor);\n\tconst t_one tmp016 = c_one;\n\tfloat tmp013 = mix(tmp000.v_min_roughness, tmp000.v_max_roughness, tmp011);\n\treturn t_mat_metal_brushed_outlet(tmp017, tmp013, tmp016.v_value);\n}\n\n// FUNCID(391) 1i->1o ComposeFuncType::Terminal [float_to_xz_vec3_inlet,float_to_xz_vec3_outlet,compute_float_to_xz_vec3]\n// ...\n// ...\nt_float_to_xz_vec3_outlet compute_float_to_xz_vec3(float a_i0) {\n\tt_float_to_xz_vec3_inlet tmp000 = t_float_to_xz_vec3_inlet(a_i0);\n\tconst t_zero tmp003 = c_zero;\n\tvec3 tmp002 = vec3(tmp000.v_i0, tmp003.v_value, tmp000.v_i0);\n\treturn t_float_to_xz_vec3_outlet(tmp002);\n}\n\n// FUNCID(346) 1i->4o ComposeFuncType::Terminal [position,outlet,compute_main_digraph]\n// ...\n// ...\nt_outlet compute_main_digraph(vec3 a_pos) {\n\tt_modpre_directional_displacement_outlet tmp055 = compute_modpre_directional_displacement(compute_modpre_morph(compute_modpre_shell(compute_modpre_smooth_difference(t_position(a_pos).v_pos, c_vase_const.v_factor).v_pos0, u_dimension.v_thickness).v_pos, u_morph_input.v_sphere).v_pos0, compute_gradient_y(t_position(a_pos).v_pos, u_dimension.v_height, u_deformation.v_grad_bot, c_zero.v_value).v_o0, compute_float_to_xz_vec3(u_deformation.v_grad_bot_int).v_o0);\n\tt_modpre_directional_displacement_outlet tmp059 = compute_modpre_directional_displacement(tmp055.v_pos, compute_gradient_y(t_position(a_pos).v_pos, u_dimension.v_height, u_deformation.v_grad_top, c_one.v_value).v_o0, compute_float_to_xz_vec3(u_deformation.v_grad_top_int).v_o0);\n\tt_modpre_shell_outlet tmp051 = compute_modpre_shell(compute_modpre_smooth_difference(t_position(a_pos).v_pos, c_vase_const.v_factor).v_pos0, u_dimension.v_thickness);\n\tconst t_minus_one tmp018 = c_minus_one;\n\tt_modpre_morph_outlet tmp065 = compute_modpre_morph(tmp059.v_pos, u_morph_input.v_cone);\n\tfloat tmp016 = (u_dimension.v_height - (u_dimension.v_height * u_morph_input.v_sphere_scale));\n\tt_modpre_morph_outlet tmp079 = compute_modpre_morph(compute_modpre_morph(tmp065.v_pos0, u_morph_input.v_hex).v_pos0, u_morph_input.v_box);\n\tt_modpre_morph_outlet tmp061 = compute_modpre_morph(compute_modpre_smooth_union(compute_modpre_morph(tmp051.v_pos, u_morph_input.v_sphere).v_pos1, u_morph_input.v_sphere_smooth).v_pos0, u_morph_input.v_cone);\n\tconst t_two tmp026 = c_two;\n\tfloat tmp011 = ((tmp016 * tmp018.v_value) * u_morph_input.v_sphere_offset);\n\tfloat tmp019 = (tmp016 * tmp018.v_value);\n\tt_modpre_morph_outlet tmp073 = compute_modpre_morph(tmp065.v_pos0, u_morph_input.v_hex);\n\tvec3 tmp029 = vec3(u_dimension.v_radius, u_dimension.v_height, u_dimension.v_radius);\n\tt_morph_input tmp001 = u_morph_input;\n\tt_modpre_morph_outlet tmp053 = compute_modpre_morph(tmp051.v_pos, u_morph_input.v_sphere);\n\tconst t_minus_one tmp022 = c_minus_one;\n\tt_sdf_box_outlet tmp080 = compute_sdf_box(tmp079.v_pos1, tmp029);\n\tt_modpre_translate_outlet tmp075 = compute_modpre_translate(tmp065.v_pos1, vec3(c_zero.v_value, (u_dimension.v_height * tmp022.v_value), c_zero.v_value));\n\tt_sdf_cylinder_outlet tmp081 = compute_sdf_cylinder(tmp079.v_pos0, u_dimension.v_height, u_dimension.v_radius);\n\tt_modpre_morph_outlet tmp077 = compute_modpre_morph(compute_modpre_morph(tmp061.v_pos0, u_morph_input.v_hex).v_pos0, u_morph_input.v_box);\n\tt_dimension tmp002 = u_dimension;\n\tfloat tmp023 = (tmp002.v_height * tmp022.v_value);\n\tconst t_one tmp014 = c_one;\n\tfloat tmp012 = (tmp019 + tmp011);\n\tt_modpre_translate_outlet tmp071 = compute_modpre_translate(compute_modpre_difference(compute_modpre_smooth_union(tmp053.v_pos1, u_morph_input.v_sphere_smooth).v_pos1).v_pos0, vec3(c_zero.v_value, tmp012, c_zero.v_value));\n\tt_modpre_translate_outlet tmp069 = compute_modpre_translate(tmp061.v_pos1, vec3(c_zero.v_value, tmp023, c_zero.v_value));\n\tt_modpre_morph_outlet tmp067 = compute_modpre_morph(tmp061.v_pos0, u_morph_input.v_hex);\n\tt_modpre_smooth_union_outlet tmp057 = compute_modpre_smooth_union(tmp053.v_pos1, u_morph_input.v_sphere_smooth);\n\tconst t_minus_one tmp010 = c_minus_one;\n\tfloat tmp027 = (tmp002.v_height * tmp026.v_value);\n\tconst t_zero tmp024 = c_zero;\n\tconst t_zero tmp020 = c_zero;\n\tfloat tmp017 = (tmp002.v_height * tmp001.v_sphere_scale);\n\tconst t_zero tmp013 = c_zero;\n\tt_modpost_morph_outlet tmp078 = compute_modpost_morph(tmp081.v_dist, tmp080.v_dist, u_morph_input.v_box);\n\tt_sdf_hexagonal_prism_outlet tmp085 = compute_sdf_hexagonal_prism(tmp073.v_pos1, u_dimension.v_radius, u_dimension.v_height);\n\tt_sdf_cone_outlet tmp084 = compute_sdf_cone(tmp075.v_pos, tmp027, u_dimension.v_radius);\n\tt_sdf_cylinder_outlet tmp083 = compute_sdf_cylinder(tmp077.v_pos0, u_dimension.v_height, u_dimension.v_radius);\n\tt_sdf_box_outlet tmp082 = compute_sdf_box(tmp077.v_pos1, tmp029);\n\tvec3 tmp025 = vec3(tmp024.v_value, tmp023, tmp024.v_value);\n\tconst t_one tmp032 = c_one;\n\tt_sdf_hexagonal_prism_outlet tmp088 = compute_sdf_hexagonal_prism(tmp067.v_pos1, u_dimension.v_radius, u_dimension.v_height);\n\tt_modpre_difference_outlet tmp063 = compute_modpre_difference(tmp057.v_pos1);\n\tt_modpost_morph_outlet tmp076 = compute_modpost_morph(tmp083.v_dist, tmp082.v_dist, u_morph_input.v_box);\n\tvec3 tmp021 = vec3(tmp020.v_value, tmp012, tmp020.v_value);\n\tvec3 tmp015 = vec3(tmp013.v_value, tmp014.v_value, tmp013.v_value);\n\tt_sdf_cone_outlet tmp087 = compute_sdf_cone(tmp069.v_pos, tmp027, u_dimension.v_radius);\n\tfloat tmp009 = (tmp002.v_height * tmp010.v_value);\n\tt_modpost_translate_outlet tmp074 = compute_modpost_translate(tmp084.v_dist, tmp025);\n\tt_modpost_morph_outlet tmp072 = compute_modpost_morph(tmp078.v_dist, tmp085.v_dist, u_morph_input.v_hex);\n\tt_sdf_sphere_outlet tmp086 = compute_sdf_sphere(tmp071.v_pos, tmp017);\n\tconst t_zero tmp031 = c_zero;\n\tt_deformation tmp003 = u_deformation;\n\tt_position tmp047 = t_position(a_pos);\n\tt_gradient_y_outlet tmp033 = compute_gradient_y(tmp047.v_pos, u_dimension.v_height, tmp003.v_grad_top, tmp032.v_value);\n\tt_modpost_morph_outlet tmp066 = compute_modpost_morph(tmp076.v_dist, tmp088.v_dist, u_morph_input.v_hex);\n\tt_float_to_xz_vec3_outlet tmp004 = compute_float_to_xz_vec3(tmp003.v_grad_top_int);\n\tt_sdf_plane_outlet tmp089 = compute_sdf_plane(tmp063.v_pos1, tmp015, tmp009);\n\tconst t_two tmp039 = c_two;\n\tt_modpost_morph_outlet tmp064 = compute_modpost_morph(tmp072.v_dist, tmp074.v_dist, u_morph_input.v_cone);\n\tt_modpost_translate_outlet tmp070 = compute_modpost_translate(tmp086.v_dist, tmp021);\n\tt_modpost_translate_outlet tmp068 = compute_modpost_translate(tmp087.v_dist, tmp025);\n\tt_modpost_morph_outlet tmp060 = compute_modpost_morph(tmp066.v_dist, tmp068.v_dist, u_morph_input.v_cone);\n\tt_modpost_directional_displacement_outlet tmp058 = compute_modpost_directional_displacement(tmp064.v_dist, tmp033.v_o0, tmp004.v_o0);\n\tt_float_to_xz_vec3_outlet tmp005 = compute_float_to_xz_vec3(tmp003.v_grad_bot_int);\n\tfloat tmp038 = (u_dimension.v_height * tmp039.v_value);\n\tconst t_minus_one tmp036 = c_minus_one;\n\tt_gradient_y_outlet tmp030 = compute_gradient_y(tmp047.v_pos, u_dimension.v_height, tmp003.v_grad_bot, tmp031.v_value);\n\tt_modpost_difference_outlet tmp062 = compute_modpost_difference(tmp070.v_dist, tmp089.v_dist);\n\tfloat tmp035 = (u_dimension.v_offset * tmp038);\n\tt_position tmp006 = t_position(a_pos);\n\tt_morph_input tmp028 = u_morph_input;\n\tconst t_zero tmp040 = c_zero;\n\tt_modpost_directional_displacement_outlet tmp054 = compute_modpost_directional_displacement(tmp058.v_dist, tmp030.v_o0, tmp005.v_o0);\n\tt_modpost_smooth_union_outlet tmp056 = compute_modpost_smooth_union(tmp060.v_dist, tmp062.v_dist, tmp028.v_sphere_smooth);\n\tconst t_minus_one tmp041 = c_minus_one;\n\tfloat tmp037 = (u_dimension.v_height * tmp036.v_value);\n\tt_dimension tmp045 = u_dimension;\n\tt_modpost_morph_outlet tmp052 = compute_modpost_morph(tmp054.v_dist, tmp056.v_dist, tmp028.v_sphere);\n\tt_modpre_smooth_difference_outlet tmp049 = compute_modpre_smooth_difference(tmp006.v_pos, c_vase_const.v_factor);\n\tvec3 tmp042 = vec3(tmp040.v_value, tmp041.v_value, tmp040.v_value);\n\tfloat tmp034 = (tmp037 + tmp035);\n\tt_float_to_vec3_outlet tmp044 = compute_float_to_vec3(u_mat.v_col);\n\tt_mat tmp043 = u_mat;\n\tt_sdf_plane_outlet tmp090 = compute_sdf_plane(tmp049.v_pos1, tmp042, tmp034);\n\tt_position tmp007 = t_position(a_pos);\n\tt_modpost_shell_outlet tmp050 = compute_modpost_shell(tmp052.v_dist, tmp045.v_thickness);\n\tconst t_vase_const tmp000 = c_vase_const;\n\tt_mat_metal_brushed_outlet tmp008 = compute_mat_metal_brushed(tmp007.v_pos, tmp044.v_o0, tmp043.v_min_rough, tmp043.v_max_rough, tmp043.v_aniso);\n\tt_modpost_smooth_difference_outlet tmp048 = compute_modpost_smooth_difference(tmp050.v_dist, tmp090.v_dist, tmp000.v_factor);\n\treturn t_outlet(tmp048.v_dist, tmp008.v_basecolor, tmp008.v_roughness, tmp008.v_metallic);\n}\n\nfloat eval_distance(vec3 pos) {\n\treturn compute_main_digraph(pos).v_dist;\n}\nvec3 eval_basecolor(vec3 pos) {\n\treturn compute_main_digraph(pos).v_basecolor;\n}\nfloat eval_roughness(vec3 pos) {\n\treturn compute_main_digraph(pos).v_roughness;\n}\nfloat eval_metallic(vec3 pos) {\n\treturn compute_main_digraph(pos).v_metallic;\n}\n", "box_cylinder_twist": "//// PREAMBLE\n\nfloat opp(float vv) { return -vv; }\n\nfloat vmin(vec2 vv) { return min(vv.x, vv.y); }\nfloat vmin(vec3 vv) { return min(min(vv.x, vv.y), vv.z); }\nfloat vmin(vec4 vv) { return min(min(vv.x, vv.y), min(vv.z, vv.w)); }\n\nfloat vmax(vec2 vv) { return max(vv.x, vv.y); }\nfloat vmax(vec3 vv) { return max(max(vv.x, vv.y), vv.z); }\nfloat vmax(vec4 vv) { return max(max(vv.x, vv.y), max(vv.z, vv.w)); }\n\n// According to the Kronos documentation, the fract of the input is computing\n// in this way 'x-floor(x)' which result to wrong results with negative values.\nfloat fractOfPositiveAndNegativeValue(float vv) {\n  return vv < 0.0 ? vv - ceil(vv) : vv - floor(vv);\n}\nvec2 fractOfPositiveAndNegativeValue(vec2 vv) {\n  return vec2(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y));\n}\nvec3 fractOfPositiveAndNegativeValue(vec3 vv) {\n  return vec3(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z));\n}\nvec4 fractOfPositiveAndNegativeValue(vec4 vv) {\n  return vec4(\n    fractOfPositiveAndNegativeValue(vv.x),\n    fractOfPositiveAndNegativeValue(vv.y),\n    fractOfPositiveAndNegativeValue(vv.z),\n    fractOfPositiveAndNegativeValue(vv.w));\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n  float n = dot(i, step);\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n             mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                 mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(float x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  float shift = float(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec2 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec2 shift = vec2(100);\n  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = rot * x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat fbm(vec3 x, float octaves) {\n  float v = 0.0;\n  float a = 0.5;\n  vec3 shift = vec3(100);\n  int num_octaves = int(octaves);\n  for (int i = 0; i < num_octaves; ++i) {\n    v += a * noise(x);\n    x = x * 2.0 + shift;\n    a *= 0.5;\n  }\n  return v;\n}\n\n// https://www.pcg-random.org/\nfloat noisePcg(float q){\n  uint v = uint(round(q));\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float(float((word >> 22u) ^ word) * (1.0/float(0xffffffffu))) ;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh  \nvec2 noisePcg(vec2 q){\n  uvec2 v = uvec2(q);\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  v.x += v.y * 1664525u;\n  v.y += v.x * 1664525u;\n\n  v = v ^ (v>>16u);\n\n  return vec2(vec2(v)* (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec3 noisePcg(vec3 q){\n  uvec3 v = uvec3(q);\n  v = v * 1664525u + 1013904223u;\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  \n  return vec3(vec3(v) * (1.0/float(0xffffffffu)));\n}\n\n// http://www.jcgt.org/published/0009/03/02/\n// https://www.shadertoy.com/view/XlGcRh\nvec4 noisePcg(vec4 q){\n  uvec4 v = uvec4(q);\n  v = v * 1664525u + 1013904223u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  v ^= v >> 16u;\n  \n  v.x += v.y*v.w;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n  v.w += v.y*v.z;\n  \n  return vec4(vec4(v) * (1.0/float(0xffffffffu)));\n}\n\n\n//// CUSTOM TYPES\n\nstruct t_zero {\n\tfloat v_value;\n};\n\nstruct t_box_width {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_box_position {\n\tfloat v_X;\n\tfloat v_Y;\n\tfloat v_Z;\n};\n\nstruct t_twist_params {\n\tfloat v_twist_angle;\n};\n\nstruct t_box_cylinder {\n\tfloat v_factor;\n};\n\nstruct t_half_pi {\n\tfloat v_value;\n};\n\nstruct t_one {\n\tfloat v_value;\n};\n\nstruct t_minus_one {\n\tfloat v_value;\n};\n\nstruct t_modpre_morph_inlet {\n\tvec3 v_pos;\n\tfloat v_factor;\n};\nstruct t_modpre_morph_outlet {\n\tvec3 v_pos0;\n\tvec3 v_pos1;\n};\n\nstruct t_modpre_rotate_inlet {\n\tvec3 v_pos;\n\tfloat v_angle_x;\n\tfloat v_angle_y;\n\tfloat v_angle_z;\n};\nstruct t_modpre_rotate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_sdf_cylinder_inlet {\n\tvec3 v_pos;\n\tfloat v_height;\n\tfloat v_radius;\n};\nstruct t_sdf_cylinder_outlet {\n\tfloat v_dist;\n};\n\nstruct t_sdf_box_inlet {\n\tvec3 v_pos;\n\tvec3 v_bounding_box;\n};\nstruct t_sdf_box_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpost_morph_inlet {\n\tfloat v_dist0;\n\tfloat v_dist1;\n\tfloat v_factor;\n};\nstruct t_modpost_morph_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpost_rotate_inlet {\n\tfloat v_dist;\n\tfloat v_angle_x;\n\tfloat v_angle_y;\n\tfloat v_angle_z;\n};\nstruct t_modpost_rotate_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_twist_inlet {\n\tvec3 v_pos;\n\tfloat v_angle;\n\tfloat v_start;\n\tfloat v_end;\n};\nstruct t_modpre_twist_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_twist_inlet {\n\tfloat v_dist;\n\tfloat v_angle;\n\tfloat v_start;\n\tfloat v_end;\n};\nstruct t_modpost_twist_outlet {\n\tfloat v_dist;\n};\n\nstruct t_modpre_translate_inlet {\n\tvec3 v_pos;\n\tvec3 v_offset;\n};\nstruct t_modpre_translate_outlet {\n\tvec3 v_pos;\n};\n\nstruct t_modpost_translate_inlet {\n\tfloat v_dist;\n\tvec3 v_offset;\n};\nstruct t_modpost_translate_outlet {\n\tfloat v_dist;\n};\n\nstruct t_position {\n\tvec3 v_pos;\n};\nstruct t_outlet {\n\tfloat v_dist;\n};\n\n//// PROTOTYPES\n\n// float sin(float a_i); // FUNCID(98) builtin operator\n// float min(float a_a, float a_b); // FUNCID(69) builtin operator\n// float opp(float a_i); // FUNCID(84) builtin operator\n// float operator+(float a_a, float a_b); // FUNCID(126) builtin arithmetic\n// float mix(float a_x, float a_y, float a_z); // FUNCID(25) builtin operator\n// float vmax(vec2 a_i); // FUNCID(90) builtin operator\n// vec3 max(vec3 a_a, vec3 a_b); // FUNCID(67) builtin operator\n// vec2 abs(vec2 a_i); // FUNCID(3) builtin operator\n// float operator*(float a_a, float a_b); // FUNCID(131) builtin arithmetic\n// float operator-(float a_a, float a_b); // FUNCID(138) builtin arithmetic\n// float cos(float a_i); // FUNCID(37) builtin operator\n// float max(float a_a, float a_b); // FUNCID(66) builtin operator\n// vec3 operator*(mat3 a_a, vec3 a_b); // FUNCID(130) builtin arithmetic\n// vec3 operator*(vec3 a_a, float a_b); // FUNCID(136) builtin arithmetic\n// vec3 operator-(vec3 a_a, vec3 a_b); // FUNCID(140) builtin arithmetic\n// float smoothstep(float a_x, float a_y, float a_z); // FUNCID(99) builtin operator\n// float operator/(float a_a, float a_b); // FUNCID(6) builtin arithmetic\n// vec2 operator*(mat2 a_a, vec2 a_b); // FUNCID(0) builtin arithmetic\n// float length(vec2 a_i); // FUNCID(58) builtin operator\n// vec2 max(vec2 a_a, vec2 a_b); // FUNCID(61) builtin operator\n// vec3 abs(vec3 a_i); // FUNCID(11) builtin operator\n// vec2 operator-(vec2 a_a, vec2 a_b); // FUNCID(139) builtin arithmetic\n// float length(vec3 a_i); // FUNCID(59) builtin operator\nt_modpre_morph_outlet compute_modpre_morph(vec3 a_pos, float a_factor); // FUNCID(349) terminal\nt_modpre_rotate_outlet compute_modpre_rotate(vec3 a_pos, float a_angle_x, float a_angle_y, float a_angle_z); // FUNCID(293) terminal\nt_sdf_cylinder_outlet compute_sdf_cylinder(vec3 a_pos, float a_height, float a_radius); // FUNCID(230) terminal\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box); // FUNCID(206) terminal\nt_modpost_morph_outlet compute_modpost_morph(float a_dist0, float a_dist1, float a_factor); // FUNCID(352) terminal\nt_modpost_rotate_outlet compute_modpost_rotate(float a_dist, float a_angle_x, float a_angle_y, float a_angle_z); // FUNCID(296) terminal\nt_modpre_twist_outlet compute_modpre_twist(vec3 a_pos, float a_angle, float a_start, float a_end); // FUNCID(342) terminal\nt_modpost_twist_outlet compute_modpost_twist(float a_dist, float a_angle, float a_start, float a_end); // FUNCID(345) terminal\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset); // FUNCID(286) terminal\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset); // FUNCID(289) terminal\nt_outlet compute_main_digraph(vec3 a_pos); // FUNCID(422) terminal\n\n//// INSTANCES\n\nconst t_zero c_zero = t_zero(float(0));\nuniform t_box_width u_box_width;\nuniform t_box_position u_box_position;\nuniform t_twist_params u_twist_params;\nuniform t_box_cylinder u_box_cylinder;\nconst t_half_pi c_half_pi = t_half_pi(float(1.5707964));\nconst t_one c_one = t_one(float(1));\nconst t_minus_one c_minus_one = t_minus_one(float(-1));\n\n//// IMPLEMENTATIONS\n\n// FUNCID(206) 2i->1o ComposeFuncType::Terminal [sdf_box_inlet,sdf_box_outlet,compute_sdf_box]\n// ...\n// ...\nt_sdf_box_outlet compute_sdf_box(vec3 a_pos, vec3 a_bounding_box) {\n\tconst t_zero tmp006 = c_zero;\n\tt_sdf_box_inlet tmp000 = t_sdf_box_inlet(a_pos, a_bounding_box);\n\tvec3 tmp002 = abs(tmp000.v_pos);\n\tvec3 tmp004 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp003 = (tmp002 - tmp000.v_bounding_box);\n\tvec3 tmp008 = vec3(tmp006.v_value, tmp006.v_value, tmp006.v_value);\n\tfloat tmp005 = max(tmp004.y, tmp004.z);\n\tconst t_zero tmp012 = c_zero;\n\tfloat tmp010 = max(tmp004.x, tmp005);\n\tvec3 tmp007 = max(tmp008, tmp003);\n\tfloat tmp011 = min(tmp012.v_value, tmp010);\n\tfloat tmp009 = length(tmp007);\n\tfloat tmp013 = (tmp009 + tmp011);\n\treturn t_sdf_box_outlet(tmp013);\n}\n\n// FUNCID(230) 3i->1o ComposeFuncType::Terminal [sdf_cylinder_inlet,sdf_cylinder_outlet,compute_sdf_cylinder]\n// ...\n// ...\nt_sdf_cylinder_outlet compute_sdf_cylinder(vec3 a_pos, float a_height, float a_radius) {\n\tvec2 tmp003 = vec2(t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos.x, t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos.z);\n\tvec3 tmp002 = t_sdf_cylinder_inlet(a_pos, a_height, a_radius).v_pos;\n\tfloat tmp004 = length(tmp003);\n\tt_sdf_cylinder_inlet tmp000 = t_sdf_cylinder_inlet(a_pos, a_height, a_radius);\n\tvec2 tmp006 = vec2(tmp004, tmp002.y);\n\tvec2 tmp007 = abs(tmp006);\n\tvec2 tmp005 = vec2(tmp000.v_radius, tmp000.v_height);\n\tvec2 tmp008 = (tmp007 - tmp005);\n\tvec2 tmp013 = vec2(c_zero.v_value, c_zero.v_value);\n\tconst t_zero tmp010 = c_zero;\n\tvec2 tmp012 = max(tmp008, tmp013);\n\tfloat tmp009 = vmax(tmp008);\n\tfloat tmp015 = length(tmp012);\n\tfloat tmp011 = min(tmp009, tmp010.v_value);\n\tfloat tmp014 = (tmp011 + tmp015);\n\treturn t_sdf_cylinder_outlet(tmp014);\n}\n\n// FUNCID(286) 2i->1o ComposeFuncType::Terminal [modpre_translate_inlet,modpre_translate_outlet,compute_modpre_translate]\n// ...\n// ...\nt_modpre_translate_outlet compute_modpre_translate(vec3 a_pos, vec3 a_offset) {\n\tt_modpre_translate_inlet tmp000 = t_modpre_translate_inlet(a_pos, a_offset);\n\tvec3 tmp002 = (tmp000.v_pos - tmp000.v_offset);\n\treturn t_modpre_translate_outlet(tmp002);\n}\n\n// FUNCID(289) 2i->1o ComposeFuncType::Terminal [modpost_translate_inlet,modpost_translate_outlet,compute_modpost_translate]\n// ...\n// ...\nt_modpost_translate_outlet compute_modpost_translate(float a_dist, vec3 a_offset) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_translate_inlet tmp000 = t_modpost_translate_inlet(a_dist, a_offset);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_translate_outlet(tmp002);\n}\n\n// FUNCID(293) 4i->1o ComposeFuncType::Terminal [modpre_rotate_inlet,modpre_rotate_outlet,compute_modpre_rotate]\n// ...\n// ...\nt_modpre_rotate_outlet compute_modpre_rotate(vec3 a_pos, float a_angle_x, float a_angle_y, float a_angle_z) {\n\tfloat tmp024 = (sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp020 = (sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp015 = (cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp011 = (cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z) * sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y));\n\tfloat tmp009 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_x);\n\tfloat tmp008 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_x);\n\tfloat tmp007 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y);\n\tfloat tmp005 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z);\n\tfloat tmp004 = sin(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_z);\n\tfloat tmp006 = cos(t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z).v_angle_y);\n\tfloat tmp027 = (tmp005 * tmp009);\n\tfloat tmp025 = (tmp024 * tmp008);\n\tfloat tmp023 = (tmp005 * tmp008);\n\tfloat tmp021 = (tmp020 * tmp009);\n\tfloat tmp018 = (tmp004 * tmp009);\n\tfloat tmp016 = (tmp015 * tmp008);\n\tfloat tmp014 = (tmp004 * tmp008);\n\tfloat tmp012 = (tmp011 * tmp009);\n\tfloat tmp030 = (tmp006 * tmp008);\n\tfloat tmp029 = (tmp006 * tmp009);\n\tfloat tmp028 = opp(tmp007);\n\tfloat tmp026 = (tmp025 - tmp027);\n\tfloat tmp022 = (tmp021 + tmp023);\n\tfloat tmp019 = (tmp004 * tmp006);\n\tfloat tmp017 = (tmp016 + tmp018);\n\tfloat tmp013 = (tmp012 - tmp014);\n\tfloat tmp010 = (tmp005 * tmp006);\n\tt_modpre_rotate_inlet tmp000 = t_modpre_rotate_inlet(a_pos, a_angle_x, a_angle_y, a_angle_z);\n\tmat3 tmp002 = mat3(tmp010, tmp013, tmp017, tmp019, tmp022, tmp026, tmp028, tmp029, tmp030);\n\tvec3 tmp003 = (tmp002 * tmp000.v_pos);\n\treturn t_modpre_rotate_outlet(tmp003);\n}\n\n// FUNCID(296) 4i->1o ComposeFuncType::Terminal [modpost_rotate_inlet,modpost_rotate_outlet,compute_modpost_rotate]\n// ...\n// ...\nt_modpost_rotate_outlet compute_modpost_rotate(float a_dist, float a_angle_x, float a_angle_y, float a_angle_z) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_rotate_inlet tmp000 = t_modpost_rotate_inlet(a_dist, a_angle_x, a_angle_y, a_angle_z);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_rotate_outlet(tmp002);\n}\n\n// FUNCID(342) 4i->1o ComposeFuncType::Terminal [modpre_twist_inlet,modpre_twist_outlet,compute_modpre_twist]\n// ...\n// ...\nt_modpre_twist_outlet compute_modpre_twist(vec3 a_pos, float a_angle, float a_start, float a_end) {\n\tfloat tmp014 = (t_modpre_twist_inlet(a_pos, a_angle, a_start, a_end).v_pos.y - t_modpre_twist_inlet(a_pos, a_angle, a_start, a_end).v_start);\n\tfloat tmp013 = (t_modpre_twist_inlet(a_pos, a_angle, a_start, a_end).v_end - t_modpre_twist_inlet(a_pos, a_angle, a_start, a_end).v_start);\n\tconst t_one tmp018 = c_one;\n\tconst t_zero tmp017 = c_zero;\n\tfloat tmp015 = (tmp014 / tmp013);\n\tfloat tmp019 = smoothstep(tmp017.v_value, tmp018.v_value, tmp015);\n\tfloat tmp003 = (tmp019 * t_modpre_twist_inlet(a_pos, a_angle, a_start, a_end).v_angle);\n\tconst t_minus_one tmp008 = c_minus_one;\n\tfloat tmp006 = sin(tmp003);\n\tfloat tmp005 = cos(tmp003);\n\tfloat tmp007 = (tmp006 * tmp008.v_value);\n\tmat2 tmp009 = mat2(tmp005, tmp007, tmp006, tmp005);\n\tvec2 tmp004 = vec2(t_modpre_twist_inlet(a_pos, a_angle, a_start, a_end).v_pos.x, t_modpre_twist_inlet(a_pos, a_angle, a_start, a_end).v_pos.z);\n\tt_modpre_twist_inlet tmp000 = t_modpre_twist_inlet(a_pos, a_angle, a_start, a_end);\n\tvec2 tmp010 = (tmp009 * tmp004);\n\tvec3 tmp002 = tmp000.v_pos;\n\tvec2 tmp011 = tmp010;\n\tvec3 tmp012 = vec3(tmp011.x, tmp002.y, tmp011.y);\n\treturn t_modpre_twist_outlet(tmp012);\n}\n\n// FUNCID(345) 4i->1o ComposeFuncType::Terminal [modpost_twist_inlet,modpost_twist_outlet,compute_modpost_twist]\n// ...\n// ...\nt_modpost_twist_outlet compute_modpost_twist(float a_dist, float a_angle, float a_start, float a_end) {\n\tconst t_zero tmp003 = c_zero;\n\tt_modpost_twist_inlet tmp000 = t_modpost_twist_inlet(a_dist, a_angle, a_start, a_end);\n\tfloat tmp002 = (tmp000.v_dist + tmp003.v_value);\n\treturn t_modpost_twist_outlet(tmp002);\n}\n\n// FUNCID(349) 2i->2o ComposeFuncType::Terminal [modpre_morph_inlet,modpre_morph_outlet,compute_modpre_morph]\n// ...\n// ...\nt_modpre_morph_outlet compute_modpre_morph(vec3 a_pos, float a_factor) {\n\tconst t_one tmp003 = c_one;\n\tt_modpre_morph_inlet tmp000 = t_modpre_morph_inlet(a_pos, a_factor);\n\tvec3 tmp002 = (tmp000.v_pos * tmp003.v_value);\n\treturn t_modpre_morph_outlet(tmp002, tmp002);\n}\n\n// FUNCID(352) 3i->1o ComposeFuncType::Terminal [modpost_morph_inlet,modpost_morph_outlet,compute_modpost_morph]\n// ...\n// ...\nt_modpost_morph_outlet compute_modpost_morph(float a_dist0, float a_dist1, float a_factor) {\n\tt_modpost_morph_inlet tmp000 = t_modpost_morph_inlet(a_dist0, a_dist1, a_factor);\n\tfloat tmp002 = mix(tmp000.v_dist0, tmp000.v_dist1, tmp000.v_factor);\n\treturn t_modpost_morph_outlet(tmp002);\n}\n\n// FUNCID(422) 1i->1o ComposeFuncType::Terminal [position,outlet,compute_main_digraph]\n// ...\n// ...\nt_outlet compute_main_digraph(vec3 a_pos) {\n\tt_position tmp011 = t_position(a_pos);\n\tt_modpre_translate_outlet tmp013 = compute_modpre_translate(tmp011.v_pos, vec3(u_box_position.v_X, u_box_position.v_Y, u_box_position.v_Z));\n\tt_modpre_rotate_outlet tmp019 = compute_modpre_rotate(compute_modpre_morph(compute_modpre_twist(tmp013.v_pos, u_twist_params.v_twist_angle, opp(u_box_width.v_Y), u_box_width.v_Y).v_pos, u_box_cylinder.v_factor).v_pos1, c_zero.v_value, c_zero.v_value, c_half_pi.v_value);\n\tt_modpre_twist_outlet tmp015 = compute_modpre_twist(tmp013.v_pos, u_twist_params.v_twist_angle, opp(u_box_width.v_Y), u_box_width.v_Y);\n\tfloat tmp003 = min(u_box_width.v_Z, u_box_width.v_Y);\n\tconst t_zero tmp005 = c_zero;\n\tt_modpre_morph_outlet tmp017 = compute_modpre_morph(tmp015.v_pos, u_box_cylinder.v_factor);\n\tconst t_half_pi tmp004 = c_half_pi;\n\tt_sdf_cylinder_outlet tmp020 = compute_sdf_cylinder(tmp019.v_pos, u_box_width.v_X, tmp003);\n\tvec3 tmp000 = vec3(u_box_width.v_X, u_box_width.v_Y, u_box_width.v_Z);\n\tt_box_cylinder tmp006 = u_box_cylinder;\n\tt_sdf_box_outlet tmp021 = compute_sdf_box(tmp017.v_pos0, tmp000);\n\tt_modpost_rotate_outlet tmp018 = compute_modpost_rotate(tmp020.v_dist, tmp005.v_value, tmp005.v_value, tmp004.v_value);\n\tt_box_width tmp009 = u_box_width;\n\tt_box_position tmp008 = u_box_position;\n\tt_twist_params tmp007 = u_twist_params;\n\tfloat tmp002 = opp(tmp009.v_Y);\n\tt_modpost_morph_outlet tmp016 = compute_modpost_morph(tmp021.v_dist, tmp018.v_dist, tmp006.v_factor);\n\tvec3 tmp001 = vec3(tmp008.v_X, tmp008.v_Y, tmp008.v_Z);\n\tt_modpost_twist_outlet tmp014 = compute_modpost_twist(tmp016.v_dist, tmp007.v_twist_angle, tmp002, tmp009.v_Y);\n\tt_modpost_translate_outlet tmp012 = compute_modpost_translate(tmp014.v_dist, tmp001);\n\treturn t_outlet(tmp012.v_dist);\n}\n\nfloat eval_distance(vec3 pos) {\n\treturn compute_main_digraph(pos).v_dist;\n}\nvec3 eval_basecolor(vec3 pos) {\n\treturn vec3(-1.f);\n}\nfloat eval_roughness(vec3 pos) {\n\treturn -1.f;\n}\nfloat eval_metallic(vec3 pos) {\n\treturn -1.f;\n}\n"};

        var templates_params_dict = {"couch": {"u_params": {"type": "t_params", "value": {"v_width": 0.5, "v_height": 0.0, "v_depth": 0.25, "v_armrest_width": 0.05000000074505806, "v_cushion_height": 0.05000000074505806, "v_foot_height": 0.05000000074505806, "v_back_width": 0.05000000074505806, "v_armrest_height": 0.20000000298023224, "v_back_angle": 0.0, "v_pillow_width": 0.0, "v_pillow_depth": 0.05000000074505806, "v_pillow_shell": 0.10000000149011612, "v_pillow_spacing": 0.699999988079071, "v_pillow_angle": 0.4000000059604645, "v_pillow_angle_back": 0.20000000298023224, "v_armrest_shell": 0.0, "v_back_shell": 0.0, "v_cushion_shell": 0.0}}, "u_translation": {"type": "t_translation", "value": {"v_trans_X": 0.0, "v_trans_Y": 0.0, "v_trans_Z": 0.0, "v_rot_Y": 0.0}}}, "table": {"u_params": {"type": "t_params", "value": {"v_width": 0.5, "v_height": 0.20000000298023224, "v_depth": 0.30000001192092896, "v_thickness": 0.029999999329447746, "v_foot_thickness": 0.029999999329447746, "v_foot_shell": 0.20000000298023224, "v_foot_dist_edge": 0.30000001192092896, "v_table_shell": 0.05000000074505806}}, "u_translation": {"type": "t_translation", "value": {"v_trans_X": 0.0, "v_trans_Y": 0.0, "v_trans_Z": 0.0}}}, "mug": {"u_params": {"type": "t_params", "value": {"v_radius": 0.30000001192092896, "v_thickness": 0.05999999865889549, "v_height": 0.30000001192092896, "v_handle_thickness": 0.03999999910593033, "v_handle_radius": 0.20000000298023224, "v_handle_angle": 0.0, "v_handle_vertical": 0.0, "v_handle_scale": 1.399999976158142, "v_shell": 0.0, "v_radius_bottom": 0.33000001311302185, "v_height_empty": 0.5}}, "u_translation": {"type": "t_translation", "value": {"v_trans_X": 0.0, "v_trans_Y": 0.0, "v_trans_Z": 0.0}}}, "airplane_simple": {"u_params": {"type": "t_params", "value": {"v_body_radius": 0.029999999329447746, "v_body_length": 0.20000000298023224, "v_nose_length": 0.05000000074505806, "v_tail_length": 0.05000000074505806, "v_wings_pos": 0.30000001192092896, "v_wings_length": 0.15000000596046448, "v_wings_width": 0.029999999329447746, "v_wings_thickness": 0.004999999888241291, "v_wings_angle": 0.30000001192092896, "v_stab_h_length": 0.10000000149011612, "v_stab_h_width": 0.019999999552965164, "v_stab_v_height": 0.05000000074505806, "v_stab_v_width": 0.019999999552965164}}, "u_translation": {"type": "t_translation", "value": {"v_trans_X": 0.0, "v_trans_Y": 0.0, "v_trans_Z": 0.0, "v_rot_Y": 0.0}}}, "car": {"u_translation": {"type": "t_translation", "value": {"v_offset": [0.0, 0.0, 0.0]}}, "u_params": {"type": "t_params", "value": {"v_length": 0.25, "v_width": 0.12999999523162842, "v_height": 0.03999999910593033, "v_top_length": 0.07000000029802322, "v_top_width": 0.07000000029802322, "v_top_height": 0.013000000268220901, "v_top_smooth": 0.10000000149011612, "v_top_shift_length": -0.07999999821186066, "v_shell": 0.07000000029802322, "v_top_shell": 0.029999999329447746, "v_wheels_radius": 0.03999999910593033, "v_wheels_width": 0.009999999776482582, "v_wheels_pos_length": 0.5, "v_wheels_pos_width": 0.8999999761581421, "v_wheels_pos_height": -0.4000000059604645, "v_wheels_shell": 0.006000000052154064}}}, "box_simple": {"u_box_width": {"type": "t_box_width", "value": {"v_X": 0.10000000149011612, "v_Y": 0.10000000149011612, "v_Z": 0.20000000298023224}}, "u_box_position": {"type": "t_box_position", "value": {"v_X": 0.0, "v_Y": 0.0, "v_Z": 0.0}}}, "box_double": {"u_box_width": {"type": "t_box_width", "value": {"v_X": 0.10000000149011612, "v_Y": 0.05000000074505806, "v_Z": 0.20000000298023224}}, "u_box_position": {"type": "t_box_position", "value": {"v_X": 0.0, "v_Y": -0.05000000074505806, "v_Z": 0.0}}, "u_box_width_top": {"type": "t_box_width_top", "value": {"v_X": 0.10000000149011612, "v_Y": 0.05000000074505806, "v_Z": 0.20000000298023224}}, "u_box_position_top": {"type": "t_box_position_top", "value": {"v_X": 0.0, "v_Y": 0.05000000074505806, "v_Z": 0.0}}}, "box_three": {"u_box_width_right": {"type": "t_box_width_right", "value": {"v_X": 0.10000000149011612, "v_Y": 0.05000000074505806, "v_Z": 0.10000000149011612}}, "u_box_width_left": {"type": "t_box_width_left", "value": {"v_X": 0.10000000149011612, "v_Y": 0.05000000074505806, "v_Z": 0.10000000149011612}}, "u_box_position_right": {"type": "t_box_position_right", "value": {"v_X": 0.0, "v_Y": -0.10000000149011612, "v_Z": -0.10000000149011612}}, "u_box_position_left": {"type": "t_box_position_left", "value": {"v_X": 0.0, "v_Y": -0.10000000149011612, "v_Z": 0.10000000149011612}}, "u_box_width_top": {"type": "t_box_width_top", "value": {"v_X": 0.10000000149011612, "v_Y": 0.05000000074505806, "v_Z": 0.20000000298023224}}, "u_box_position_top": {"type": "t_box_position_top", "value": {"v_X": 0.0, "v_Y": 0.0, "v_Z": 0.0}}}, "vase_generator_fixbw": {"u_dimension": {"type": "t_dimension", "value": {"v_height": 0.2150000035762787, "v_radius": 0.05999999865889549, "v_thickness": 0.004000000189989805, "v_offset": 0.019999999552965164, "v_fac": 0.004999999888241291}}, "u_mat": {"type": "t_mat", "value": {"v_min_rough": 0.10499999672174454, "v_max_rough": 0.23999999463558197, "v_col": 0.7799999713897705, "v_aniso": [5.0, 2048.0, 1024.0]}}, "u_deformation": {"type": "t_deformation", "value": {"v_grad_top": 0.8399999737739563, "v_grad_top_int": 0.2800000011920929, "v_grad_bot": 1.0, "v_grad_bot_int": 0.5799999833106995}}, "u_morph_input": {"type": "t_morph_input", "value": {"v_box": 0.0, "v_hex": 0.7250000238418579, "v_cone": 0.0, "v_sphere": 0.39500001072883606, "v_sphere_scale": 0.7400000095367432, "v_sphere_smooth": 0.054999999701976776, "v_sphere_offset": 1.0}}}, "box_cylinder_twist": {"u_box_width": {"type": "t_box_width", "value": {"v_X": 0.30000001192092896, "v_Y": 0.10000000149011612, "v_Z": 0.10000000149011612}}, "u_box_position": {"type": "t_box_position", "value": {"v_X": 0.0, "v_Y": 0.0, "v_Z": 0.0}}, "u_twist_params": {"type": "t_twist_params", "value": {"v_twist_angle": 0.0}}, "u_box_cylinder": {"type": "t_box_cylinder", "value": {"v_factor": 0.0}}}};

        var viewport_width = 800;
        var scene;
        var camera;
        var controls;
        var light;
        var lightSide;
        var lightSide2;
        var renderer;

        var raymarcher_mesh;

        function setupScene()
        {
          scene = new THREE.Scene();
          scene.background = new THREE.Color( 0xffffff );
          camera = new THREE.PerspectiveCamera( 45, viewport_width / viewport_width, 0.1, 1000 );

          camera.position.set(2, 2, 2);

          controls = new OrbitControls(camera, document.getElementById('scene'));
          controls.target.set(0, 0, 0);
          controls.update();

          light = new THREE.DirectionalLight( 0xffffff, 0.5 );
          scene.add( light );

          lightSide = new THREE.DirectionalLight( 0xffffff, 0.7 );
          lightSide.position.set(1,0,1);
          scene.add( lightSide );

          lightSide2 = new THREE.DirectionalLight( 0xffffff, 0.7 );
          lightSide2.position.set(-1,0,-1);
          scene.add( lightSide2 );

          renderer = new THREE.WebGLRenderer({canvas : document.getElementById('scene')});
          renderer.setSize( viewport_width, viewport_width );

          // Setup shader material

          // SDF ray marching
          // https://github.com/nicoptere/raymarching-for-THREE/blob/master/interactive.html

          // Code from : https://github.com/nicoptere/raymarching-for-THREE/blob/master/raymarcher.js

          const raymarcher_distance = 50;
          const raymarcher_precision = 0.0001;

          const raymarcher_geom = new THREE.BufferGeometry();
          raymarcher_geom.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array([   -1,-1,0, 1,-1,0, 1,1,0, -1, -1, 0, 1, 1, 0, -1, 1, 0]), 3 ) );
          raymarcher_mesh = new THREE.Mesh( raymarcher_geom, null );

          // Create shader material using loaded fragment shader
          raymarcher_mesh.material = new THREE.ShaderMaterial({

              uniforms :{
                  resolution:{ type:"v2", value:new THREE.Vector2( viewport_width, viewport_width ) },
                  randomSeed:{ type:"f", value:Math.random() },
                  fov:{ type:"f", value:camera.aspect / Math.tan(camera.fov / 2 * Math.PI / 180) },
                  camera:{ type:"v3", value:camera.position },
                  target:{ type:"v3", value:controls.target },
                  raymarchMaximumDistance:{ type:"f", value:raymarcher_distance },
                  raymarchPrecision:{ type:"f", value:raymarcher_precision},
                  color0:{ type:"v3", value: new THREE.Vector3(0.6, 0.6, 0.6) },
                  light0:{ type:"v3", value: light.position },
                  color1:{ type:"v3", value:  new THREE.Vector3(0.6, 0.6, 0.6) },
                  color2:{ type:"v3", value:  new THREE.Vector3(0.6, 0.6, 0.6) },
                  light1:{ type:"v3", value: lightSide.position },
              },
              vertexShader : "void main() {gl_Position =  vec4( position, 1.0 );}",
              // fragmentShader : fragmentComplete,
              transparent:true
          });

          scene.add( raymarcher_mesh );
        }

        function setTemplate()
        {
            var template_name = document.getElementById("template").value;
            
            raymarcher_mesh.material.fragmentShader = templates_glsl_dict[template_name] + raymarching_glsl_code;
            raymarcher_mesh.material.needsUpdate  = true;
            
            updateParameters(templates_params_dict[template_name]);
        }

        function updateParamsShader()
        {
          var template_name = document.getElementById("template").value;
          var parameters = templates_params_dict[template_name];
          for (const key in parameters) {
            var param = structuredClone(parameters[key]);
            for (const pkey in param.value) {
              var param_name = key+"__"+pkey;
              if (typeof param.value[pkey] == "object"){
                for (const pkeyo in param.value[pkey]) {
                  param.value[pkey][pkeyo] = document.getElementById("slider_param_"+param_name+"__"+pkeyo).valueAsNumber;
                  document.getElementById("slider_param_"+param_name+"__"+pkeyo+"_disp").innerHTML = document.getElementById("slider_param_"+param_name+"__"+pkeyo).valueAsNumber.toFixed(3);
                }
              }
              else {
                param.value[pkey] = document.getElementById("slider_param_"+param_name).valueAsNumber;
                document.getElementById("slider_param_"+param_name+"_disp").innerHTML = document.getElementById("slider_param_"+param_name).valueAsNumber.toFixed(3);
              }
            }
            raymarcher_mesh.material.uniforms[ `${key}` ] = param;
          }
        }
        function slider_html_str(param_name, param_str, val)
        {
          return "<tr><td style=\"min-width:200px;\">"+param_str+"</td><td>" + "<input type=\"range\" min=\"-1\" max=\"1\" step=\"0.001\" value=\"" + val + "\" class=\"slider\" id=\"slider_param_"+param_name+"\">" + "</td><td style=\"min-width:50px;\" id=\"slider_param_"+param_name+"_disp\">" + val.toFixed(3) + "</td>\n";
        }

        function updateParameters(parameters)
        {
          var params_list_str = "<table>\n"
          var all_slider_ids = [];
          for (const key in parameters) {

              raymarcher_mesh.material.uniforms[ `${key}` ] = parameters[key];

              // update list display
              for (const pkey in parameters[key].value) {
                var val = parameters[key].value[pkey];
                var param_name = key+"__"+pkey;
                // var param_str = key.replace("u_","").replaceAll("_"," ") + " : " + pkey.replace("v_","").replaceAll("_"," ");
                var param_str = pkey.replace("v_","").replaceAll("_"," ");
                if (typeof val == "object"){  // handle arrays (vectors)
                  for (const pkeyo in val) {
                    params_list_str += slider_html_str(param_name+"__"+pkeyo, param_str + " [" + pkeyo + "]", val[pkeyo]);
                    all_slider_ids.push(param_name+"__"+pkeyo);
                  }
                }
                else {
                  params_list_str += slider_html_str(param_name, param_str, val);
                  all_slider_ids.push(param_name);
                }
              }
          }
          params_list_str += "</table>\n";
          document.getElementById("params_list").innerHTML = params_list_str;

          for (const id in all_slider_ids) {
            document.getElementById("slider_param_"+all_slider_ids[id]).oninput = updateParamsShader;
          }
        }

        function render()
        {
            renderer.render( scene, camera );
            requestAnimationFrame(render);
        }

        // main

        setupScene();
        setTemplate();

        document.getElementById("template").onchange = setTemplate;

        requestAnimationFrame(render); // start render loop

    </script>

    </body>
</html>
